####
#### Тема 1. Вступ до Python
####


###
### Синтаксис, змінні, типи даних, оператори
###


# Введення (отримання даних)
#ім_я = input("Введіть ваше ім'я: ")

# Перетворення (обробка даних)
#вітання = f"Привіт, {ім_я}!"

# Виведення (виведення даних)
#print(вітання)


## Змінні
 
age = 20
user_name = "Boris"
user_age = 30
ADULT_THR = 18


## Типи даних

   # Числа
a = 0.2 + 0.1
print(a)

int_number = 3
float_number = 3.3
complex_number = 3.3 + 2j

print(int_number)
print(float_number)
print(complex_number)


  # Логічний тип (bool)

is_active = True
is_delete = False

print(is_active)
print(is_delete)


age = 18
is_adult = age >= 18  # True
print(is_adult)


  # Рядки (рядкові змінні)

message = "Hello world"
print(message[0])

s1 = "Hello"
s2 = "world!"
joined_string = s1 + " " + s2
print(joined_string)

name = "Oleg"
hello_string = f"Hello, {name}!"
print(hello_string)

s1 = 'Hello'
s2 = 'world!'
joined_string = f"{s1} {s2}"  # Hello world!
print(joined_string)


  # Тип None

connect_to_database = None
print(connect_to_database)


## Інструкції та вирази

x = 2
y = x + 10


side_a = 10
side_b = 5
hypotenuse = (side_a**2 + side_b**2)**0.5
print(hypotenuse)

S = side_a * side_b / 2
print(S)


   #  Програма, яка переводить час із секунд, 
   # визначаючи повну кількість годин, хвилин і секунд.
n = 5000

hours = n // (60 * 60)
minutes = (n - hours * 60 * 60) // 60
seconds = n - hours * 60 * 60 - minutes * 60
print(hours)
print(minutes)
print(seconds)
time = [hours,minutes,seconds]
print(time)

10 // 3 # цілочисельне ділення (результат = 3)
10 % 3  # остача від ділення (результат = 1)

x=6
y=9
x%2  # парне число (остача 0)
y%2  # непарне число (остача 1)


  # Порядок виконання операцій у виразі

ratio = 10
result = 8 * (ratio + 5) - ratio ** 2
print(result)


-3 ** 2  # -9
(-3) ** 2  # 9

  # Програма обрахунку відстані між точками 
  # з координатами (x1, y1) та (x2, y2) 
  # (формула відстані Евкліда)

x1 = 10
y1 = 10
x2 = 25
y2 = 25
d = ((x2 - x1)**2 + (y2 - y1)**2)**0.5
print(d)


  # Коментарі
ratio = 10  # коефіцієнт корекції
result = 8 * (ratio + 5) - ratio ** 2


  # Вбудовані функції

# print(), Стандартна бібліотека Python реалізує ряд функцій, 
# які одразу доступні розробнику без необхідності їх якось імпортувати 
# Повний перелік таких функцій https://docs.python.org/3/library/functions.html

  # Вивід даних

print("Hello world!")

x = 12
print("Значення x:", x)
print(f"Значення x: {x}")

# print("Привіт", end=" ")

  
  # Введення даних

# a = input("Рядок запрошення: ")
# На екрані ви побачите: Рядок запрошення:
# print(a)


  # Приведення типів

#age = input("How old are you? ")
#age = int(age)
#print(age)

pi = float('3.14')
print(pi)

pi_str = str(3.14)
age_str = str(29)
print(pi_str)
print(age_str)

bool(0)  # False
bool(1)  # True

#a = float(input("Введіть сторону квадрата a: "))
#P = 4 * a
#print(f"Периметр квадрата дорівнює {P}")


# Приклад. Для кава-брейків на конференції закуплено круасани, 
# стаканчики та пакунки кави. Ціна круасана — $1.04, 
# ціна стаканчика — $0.34, ціна пакунка кави — $4.42. 
# Потрібно класти програму, яка обчислює, скільки повних доларів 
# пішло на закупівлю їжі для кава-брейків і яка її повна вартість 
# у центах.

# Встановлюємо ціни на продукти
#price_per_croissant = 1.04
#price_per_glass = 0.34
#price_per_coffee_pack = 4.42

# Кількість кожного продукту
#num_croissants = int(input("Введіть кількість круасанів: "))
#num_glasses = int(input("Введіть кількість склянок: "))
#num_coffee_packs = int(input("Введіть кількість упаковок кави: "))

# Обчислення загальної вартості
#total_cost = num_croissants * price_per_croissant + \
#             num_glasses * price_per_glass + \
#             num_coffee_packs * price_per_coffee_pack

# Визначаємо кількість повних доларів і центів
#total_dollars = int(total_cost)
#total_cents = int(total_cost * 100)

# Вивід результату
#print(f"Загальна вартість у повних доларах: {total_dollars} доларів")
#print(f"Загальна вартість у центах: {total_cents} центів")


###
### Робота з рядками та колекції
###

# Колекції
# 1. Списки (Lists)
# 2. Кортежі (Tuples)
# 3. Словники (Dictionaries)
# 4. Множини (Sets)
# 5. Заморожені множини (Frozen Sets)


   ## Списки (Lists)

my_list = list() # порожній список
empty_list = []  # порожній список

my_list = [1, 2, 3, 4, 5]
my_list = [1, "Hello", 3.14]
print(my_list)

my_list.append(4) # додасть число 4 в кінець списку
print(my_list)

my_list.remove("Hello") # видалить рядок "Hello" зі списку.
print(my_list)


some_iterable = ["a", "b", "c"]
first_letter = some_iterable[0] # виведе 1-й елемент списку
middle_one = some_iterable[1]   # виведе 2-й елемент списку
last_letter = some_iterable[2]  # виведе 3-й елемент списку
print(first_letter)
print(middle_one)
print(last_letter)

some_iterable = ["a", "b", "c"]
first_letter = some_iterable[-1] # виведе 1-й елемент з кінця списку (Оскільки у Python -0 == 0)
middle_one = some_iterable[-2]   # виведе 2-й елемент з кінця списку
last_letter = some_iterable[-3]  # виведе 3-й елемент з кінця списку 
print(first_letter)
print(middle_one)
print(last_letter)


some_iterable = [1, 2, 3]
print(some_iterable)

some_iterable[1] = -2 # Змінимо другий елемент списку some_iterable на -2
print(some_iterable)


chars = ['a', 'b', 'c']
chars.pop() # виводить останнє значення списку (i=-1 за замовчуванням) та видаляє його зі списку
print(chars)

chars = ['a', 'b', 'c']
chars.pop(1) # виводить 2-ге значення списку (i=1) та видаляє його зі списку
print(chars)


# Розширити один список іншим - використовують метод "extend"

chars = ['a', 'b', 'c']
numbers = [1, 2]


chars.extend(numbers) # у список chars додалися всі елементи списку numbers
print(chars)

decimals = [7,8]
digits = [5, 6]
decimals.append(digits) # append на відміну від extend додасть список digits до списку decimals не як окремі елементи, а як окремий список як один із елементів
print(decimals)


# Для вставки елемента x на позицію з індексом i у список ми використовуємо метод insert(i, x)
chars = ['a', 'c']
chars.insert(1, "b") # вставляємо на 2-гу позицію елемент "b"
print(chars)

# Для очищення списку від елементів треба використати метод clear()
chars = ['a', 'b']
chars.clear() # [] 
print(chars)

# Метод index() у списках Python використовується для знаходження індексу першого входження заданого елемента у списку. 
# Якщо елемент не знаходиться у списку, 
# Python викине помилку ValueError. 
# Обробляти такі помилки ми навчимося далі по курсу.

chars = ['a', 'b', 'c', 'd']
c_ind = chars.index('c')
print(c_ind)

# Метод count() у списках Python використовується для підрахунку 
# кількості разів, скільки певний елемент зустрічається у списку

my_list = [1, 2, 3, 4, 2, 2, 5, 2]
count_2 = my_list.count(2)
print(count_2)  # Виведе 4, оскільки число 2 зустрічається 4 рази

# вбудована функція len() виводить кількість елементів у будь-якій колекції.
my_list = [1, 2, 3, 4, 5]
print(len(my_list))

# Метод sort() у списках Python використовується для сортування 
# елементів списку в порядку зростання або спадання.
nums = [3, 1, 4, 1, 5, 9, 2]
nums.sort()
print(nums)  # Виведе [1, 1, 2, 3, 4, 5, 9] За замовчуванням sort() впорядковує елементи списку за зростанням, від меншого до більшого.

nums.sort(reverse=True)
print(nums)  # Виведе [9, 5, 4, 3, 2, 1, 1] відсортувати елементи в порядку спадання

# Метод sort() також дозволяє сортувати за ключем, який визначає, як порівнювати елементи
words = ["banana", "apple", "cherry"]
words.sort(key=len)
print(words)  # Виведе ['apple', 'banana', 'cherry'] відсортували список за довжиною слова у списку.

# Вбудований метод sorted() у Python використовується для 
# сортування колекцій. Він відрізняється від методу sort(), 
# який застосовується безпосередньо до списку, 
# та змінює його: sorted() повертає новий відсортований об'єкт, 
# залишаючи вихідний об'єкт без змін. 
# Оскільки sorted() повертає новий список, його можна використовувати з будь-якою колекцією, не тільки зі списками. Це робить sorted() дуже універсальним інструментом для сортування даних, незалежно від того, чи є вихідний об'єкт змінним.

nums = [3, 1, 4, 1, 5, 9, 2]
sorted_nums = sorted(nums)
print(sorted_nums)  # Виведе [1, 1, 2, 3, 4, 5, 9]

sorted_nums_desc = sorted(nums, reverse=True)
print(sorted_nums_desc)  # Виведе [9, 5, 4, 3, 2, 1, 1]

words = ["banana", "apple", "cherry"]
sorted_words = sorted(words, key=len)
print(sorted_words)  # Виведе ['apple', 'banana', 'cherry']

#  Метод copy() повертає копію списку

chars =  ['a', 'b']
chars_copy = chars.copy()
print(chars)
print(chars_copy)

# Метод reverse() використовується, щоб 
# змінити порядок елементів у списку на зворотний.

chars = ["banana", "apple", "cherry"]
chars.reverse()


   ## Словники (Dictionaries)

my_dict = {"name": "Alice", "age": 25, "city": "New York"}
print(my_dict["name"])  # Виведе 'Alice'

my_dict["age"] = 26  # Змінює вік на 26
my_dict["email"] = "alice@example.com"  # Додає нову пару ключ-значення
print(my_dict)

del my_dict["age"] # видаляє ключ "age" та його значення 26
print(my_dict)

print("name" in my_dict) # перевірка чи є ключ у словнику, використовуй оператор "in"
print("age" in my_dict)


  # Методи словників

# Метод pop()
my_dict = {"name": "Alice", "age": 25 }
age = my_dict.pop("age") # змінна age отримає значення 25, 
                         # а пара ключ-значення "age": 25 буде видалена зі словника
print(my_dict)           
print(age)

# Метод update()
my_dict = {"name": "Alice", "age": 25}
my_dict.update({"email": "alice@example.com", "age": 26}) #  словник my_dict буде оновлено новими парами ключ-значення, 
                                                          # де ключ "email" буде додано в словник, а значення ключа "age" буде оновлено.
print(my_dict)

# Метод clear()
my_dict.clear(), my_dict # очищує словник, видаляючи всі його елементи. Після виклику стане порожнім словником {}.
print(my_dict)

# Метод copy()
new_dict = my_dict.copy() # новий словник з тими самими парами ключ-значення, що і my_dict, але як окремий об'єкт
print(new_dict)

# Метод get() -  безпечне отримання значення за ключем зі словника
my_dict = {"name": "Alice", "age": 25}
age = my_dict.get("age")  # Поверне 25
gender = my_dict.get("gender")  # Поверне None, оскільки "gender" немає в словнику
print(age)
print(gender)


# Коли ви використовуєте квадратні дужки [] для доступу до значення 
# за ключем, отримаєте значення, якщо ключ існує. 
# Проте, якщо ключ відсутній, Python викине помилку KeyError.

name = my_dict["name"]  # Поверне 'Alice'
#gender = my_dict["gender"]  # Викличе KeyError, оскільки "gender" немає в словнику

print(name)
print(gender)

# Головна різниця між використанням get() та прямим доступом до значення 
# за ключем полягає в тому, як обробляється відсутність ключа. 
# Метод get() є більш безпечним, оскільки він запобігає виникненню помилки KeyError 
# та дозволяє тобі встановити значення за замовчуванням для випадків, коли ключ не знайдено. 
# Отже, в майбутньому краще використовуй метод get() для отримання значення за ключем зі словника.


   ## Множини (Sets)

empty_set = set()

a = set('hello')
print(a)

b = {1, 2, 3, 4, 5}
print(b)

numbers = {1, 2, 3, 1, 2, 3} # Унікальність множини передбачає, що якщо множина вже містить такий елемент, то спроба додати ще один такий самий нічого не змінить.
print(numbers)

#  множини часто використовуються, коли потрібно забезпечити унікальність 
# елементів, наприклад, для видалення дублікатів зі списку. 
# Вони також корисні в ситуаціях, де потрібно виконати швидкі 
# перевірки на наявність елемента.

# Приклад. Нехай у нас є список, з якого треба видалити дублікати
lst = [1, 2, 3, 1, 2, 2, 3, 4, 1]
d_lst = set(lst) # Це можна зробити, перетворивши список у множину
print(d_lst)

# А далі множину перетворити знову у список 
lst=list(d_lst)
print(lst) # так легко ми прибрали дублікати зі списку


  # Методи множин (sets)

# Метод add(elem) — додає елемент у множину (по аналогії з extend() для списку)
numbers = {1, 2, 3}
numbers.add(4)
print(numbers)  # {1, 2, 3, 4}

# Метод remove(elem) — видаляє елемент із множини, викликає виняток, якщо такого елемента немає (по аналогії з методом pop() для списків і словників)
numbers = {1, 2, 3}
numbers.remove(3)  # видаляє елемент 3-ку
print(numbers)  # {1, 2}
#numbers.remove(4) # KeyError: 4

# Метод discard(elem) — видаляє елемент із множини і не викликає виняток, якщо його немає
numbers = {1, 2, 3}
numbers.discard(2)
print(numbers)  # {1, 3}
numbers.discard(4)


   # Математичні операції над множинами

# Метод intersection () або оператор "&" 
# - перетин множин включає лише ті елементи, які є в обох множинах (загальні елементи для двох множин)
a = {1, 2, 3}
b = {3, 4, 5}
print(a.intersection(b))  # {3}
print(a & b)  # {3}

# Метод difference () або  оператор "-"
# Різниця між двома множинами включає елементи, 
# які містяться в першій множині, але не містяться в другій. 

a = {1, 2, 3}
b = {3, 4, 5}
print(a.difference(b))  # {1, 2}
print(a - b)  # {1, 2}

# Метод symmetric_difference () або  оператор "^"
# Симетрична різниця між двома множинами включає всі елементи, 
# які містяться в одній множині, але не містяться в іншій, і навпаки. 
# Щоб знайти всі елементи з двох множин, окрім загальних

a = {1, 2, 3}
b = {3, 4, 5}
print(a.symmetric_difference(b))  # {1, 2, 4, 5}
print(a ^ b)  # {1, 2, 4, 5}

# Метод union () або  оператор "|"
# Об'єднання двох множин включає всі елементи з обох множин, 
# але без дублікатів. 

a = {1, 2, 3}
b = {3, 4, 5}
print(a.union(b))  # {1, 2, 3, 4, 5}
print(a | b)  # {1, 2, 3, 4, 5}


# Заморожені множини в Python, відомі як frozenset, 
# є подібними до звичайних множин set, але з ключовою відмінністю: 
# вони є незмінними. Це означає, що після створення 
# замороженої множини ви не можете додати або видалити елементи з неї.

# Заморожену множину можна створити за допомогою функції frozenset():

my_frozenset = frozenset([1, 2, 3, 4, 5])

# У цьому прикладі ми створили заморожену множину з п'яти чисел.
# Неможливо змінити елементи замороженої множини після її створення. Ви не зможете використовувати методи add() або remove(), як у випадку зі звичайними множинами. Заморожені множини можуть використовуватися в якості ключів у словниках або як елементи інших множин, тому що вони є хешованими (і, отже, незмінними).
# Хоча ви не можете змінювати заморожені множини, над ними все ще можна виконувати різні операції, які не змінюють саму множину, такі як об'єднання, перетин і різниця:

a = frozenset([1, 2, 3])
b = frozenset([3, 4, 5])

union = a | b  # Об'єднання множин
intersection = a & b  # Перетин множин
difference = a - b  # Різниця множин
symmetric_difference = a ^ b  # Симетрична різниця

print(union)  # frozenset({1, 2, 3, 4, 5})
print(intersection)  # frozenset({3})
print(difference)  # frozenset({1, 2})
print(symmetric_difference)  # frozenset({1, 2, 4, 5})

# У цих прикладах результатом кожної операції буде нова заморожена множина.
# Заморожені множини корисні у випадках, коли тобі потрібно мати набір унікальних елементів, який не змінюватиметься, та коли потрібна можливість використовувати множини як ключі у словниках або як елементи інших множин.


  ## Кортежі

# Кортежі в Python — це важлива структура даних, подібна до списків, але з ключовою відмінністю: вони незмінні. Це означає, що після створення кортежу, не можна змінити його елементи, не можна додавати/видаляти/переставляти елементи. При спробі змінити кортеж, ви отримаєте повідомлення про помилку.

my_tuple = tuple() # або
my_tuple = ()
print(my_tuple)

my_tuple = (1, 2, 3)
print(my_tuple)

# Якщо ви хочете створити кортеж з одним елементом, не забудьте поставити кому. Це важливо, запам'ятай це! Інакше ви отримаєте змінну, яка просто зберігає елемент кортежу.
my_tuple = (1,)
print(my_tuple)

# Кортеж, як і список, може містити різні типи даних:
my_tuple = (1, "Hello", 3.14)

# Кортеж можна створити без дужок, ця операція називається упакування кортежу:
my_tuple = 1, "Hello", 3.14

# Із операції з кортежами ми маємо фактично тільки доступ до елементів. Ми можемо отримати доступ до елементів кортежу за допомогою індексації.
first_item = my_tuple[0]  # Отримати перший елемент
print(first_item)

# Оскільки кортежі є незмінними, неможна додавати, видаляти або змінювати їх елементи після створення. Це робить їх ідеальними для використання в ситуаціях, де потрібно гарантувати, що дані залишаться без змін.
# Кортежі використовуються в багатьох сценаріях, наприклад, для зберігання набору констант або коли функція повертає кілька значень. Також вони корисні в якості ключів словників, оскільки ключі повинні бути незмінними.
# Незмінність кортежів обмежує їх застосування, в порівнянні зі списками, але дає можливість використати кортежі як ключі для словника або елементи множини.
# Наприклад, розглянемо набір точок на площині (кортежі). Їх можна використовувати як ключі у словнику:

points = {
    (0, 0): "O",
    (1, 1): "A",
    (2, 2): "B"
}
print(points)

# 💡 Головна різниця між кортежами та списками полягає в їхній незмінності. Кортежі — це чудовий вибір, коли тобі потрібна впорядкована колекція, яка не повинна змінюватися. Списки ж ідеально підходять для випадків, коли тобі потрібна подібна до кортежу структура, але з можливістю модифікації.


  ## Методи рядків

# Рядок — це незмінна впорядкована послідовність символів у деякому кодуванні. За замовчуванням використовується кодування UTF-8, але можна працювати майже з усіма відомими таблицями кодування символів.
# У Python рядок теж можна розглядати як колекцію символів. Це означає, що рядки підтримують багато операцій, які зазвичай застосовуються до колекцій, таких як списки.


""" (shift + alt + A)
Важливо тільки пам'ятати, що рядки в Python є незмінними (immutable), це значить, що ви не можете змінити окремі символи в рядку без створення нового рядка.
Ми вже знаємо: щоб створити змінну типу "рядок", необхідно певний набір символів взяти в лапки. Ми будемо в основному використовувати два варіанти:
Варіант перший — рядок береться в одинарні лапки (апостроф) 'some text'
Варіант другий — рядок береться в подвійні лапки "some text"
Різні варіанти використання лапок обумовлені тим, що при використанні одинарних лапок можна в рядку вказати подвійні та навпаки. 
Бо інколи в тексті нам треба показати, що ми працюємо саме з рядком.

 """

game_string = 'My favorite "Game"'
print(game_string)

""" 
Впорядкована послідовність означає, що до елементів рядка можна звертатися за індексом:  """

s = "Hello world!"
print(s[0])   # H
print(s[-1])  # !

""" 
Незмінна послідовність означає, що якщо рядок уже створений, то змінити його не можна, можна тільки створити новий.
 """
s = "Hello world!"
#s[0] = "Q" # Тут буде викликано виняток (помилка) TypeError

""" 
У Python рядки мають багато корисних "малих" методів, які дозволяють виконувати різноманітні операції обробки тексту. Ці методи дуже корисні для обробки та перетворення текстових даних у Python. Вони дозволяють виконувати найрізноманітніші задачі, пов'язані з рядками, від простого форматування до більш складної обробки тексту.
 """
#Для того, щоб усі літери рядка перевести у верхній регістр, використовується метод upper:
s = "Hello" 
print(s.upper()) # Виведе 'HELLO'


# Для переведення в нижній регістр використовується метод lower():
s = "Some Text"
print(s.lower())  # Виведе 'some text'

# Щоб перевірити, що рядок починається з підрядка, є метод startswith:
s = "Bill Jons"
print(s.startswith("Bi"))  # Виведе True

# Щоб перевірити, що рядок закінчується підрядком, використовується метод endswith:
# Цей метод зручно використовувати для перевірки розширення файлів.
s = "hello.jpg"
print(s.endswith("jpg"))  # Виведе True

# Метод capitalize робить перший символ рядка великою літерою, а інші — малими:
s = "hello world".capitalize()  # Результат: "Hello world"

#Метод title перетворює перші літери кожного слова в рядку на великі:
s = "hello world".title()  # Результат: "Hello World"

# Ще можуть стати в пригоді методи isdigit, isalpha, isspace, які перевіряють, чи складається рядок тільки з цифр, літер, пробілів тощо відповідно:
"123".isdigit()  # True
"hello".isalpha()  # True
" ".isspace()  # True

""" 
Звісно, ми розглянули не всі методи, але ми ще повернемося в навчанні до роботи з методами рядків.
 """

   # Форматування рядків

""" 
До появи f- рядків у Python активно використовували метод format.
Метод format у Python використовується для форматування рядків. Він замінює {} в рядку на аргументи, які передаються методу format. Це надзвичайно корисно для створення динамічних рядків.
Розглянемо декілька прикладів використання методу format:
 """
 
# Просте форматування рядка
name = 'John'
print('Hello, {}!'.format(name))

# Форматування з декількома аргументами
age = 25
print('Hello, {}. You are {} years old.'.format(name, age))

# Використання іменованих аргументів
print('Hello, {name}. You are {age} years old.'.format(name='Jane', age=30))

# Використання індексів для вказівки порядку аргументів
print('Hello, {1}. You are {0} years old.'.format(age, name))



   # Зрізи у Python (Slice)

'''
Для впорядкованих контейнерів є спеціальний синтаксис, коли нам необхідно отримати деяку послідовність елементів з контейнера.
Зрізи (slices) у Python — це потужний механізм для доступу до частин послідовностей, таких як рядки, списки та кортежі.

Зрізи визначаються за допомогою квадратних дужок [] із вказівкою індексів початку, кінця та (необов'язково) кроку. Ось основний синтаксис:


послідовність[початок:кінець:крок]

початок — індекс елемента, з якого починається зріз. Якщо він не вказаний, зріз починається з початку послідовності, з 0.
кінець — індекс елемента, до якого йде зріз, але увага!, не включаючи його. Якщо він не вказаний, зріз іде до кінця послідовності.
крок — визначає крок, з яким вибираються елементи. Якщо не вказаний, використовується крок 1.


Наприклад, якщо ми хочемо отримати перші 5 літер рядка:
'''

s = "Hello, World!"
first_five = s[:5]
print(first_five)  # Виведе 'Hello'

'''''
Змінна first_five у цьому прикладі буде містити рядок 'Hello'.
Зверніть увагу на малюнок: з індексом 5 у нас кома , і вона не була включена у зріз.

Візьмемо список чисел від 1 до 10 і збережемо окремо парні, непарні та кратні 3 числа.
Спочатку отримаємо непарні числа списку.
'''
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
odd_numbers = numbers[0:10:2]

''''
У списку odd_numbers ми беремо числа (на малюнку синього кольору), починаючи з індексу 0 до 10 з кроком 2, отримаємо новий список [1, 3, 5, 7, 9]. Оскільки ми хочемо включити в перебори списку і десяте число (яке має індекс 9), нам слід використати саме запис numbers[0:10:2].
За замовчуванням Python розпочне зріз із початку і до кінця списку, тому ми могли б скоротити запис зрізу до виразу:
'''
odd_numbers = numbers[::2]  # Виведе [1, 3, 5, 7, 9]

''''
Це те ж саме, що і запис numbers[0:10:2].
Тепер отримаємо парні числа зі списку за допомогою зрізів.
'''

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = numbers[1:10:2]

''''
У even_numbers ми беремо числа, починаючи з індексу 1 до 10 з кроком 2, та отримаємо список [2, 4, 6, 8, 10]. Тут теж можна скоротити запис зрізу та записати.
'''
even_numbers = numbers[1::2] # Виведе [2, 4, 6, 8, 10]

'''
І нарешті отримаємо числа списку, кратні трьом.
'''
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
three_numbers = numbers[2:10:3]

'''
У three_numbers ми беремо числа, починаючи з індексу 2 до 10 з кроком 3, та отримуємо список [3, 6, 9]. Скорочений запис — three_numbers = numbers[2::3].
Ми можемо використовувати від'ємні індекси у зрізах. Із корисного, використання від'ємного кроку дозволяє "проходити" послідовність у зворотному порядку і фактично заміняє метод reverse для списків.
'''
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
reverse_numbers = numbers[::-1]
print(reverse_numbers)

'''''
Змінна reverse_numbers буде зберігати зворотний список [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Щоб зробити копію списку в Python, можна замість методу copy використати зріз з усіма елементами оригінального списку. Зробити це дуже просто — треба створити зріз, який починається з першого елемента і йде до кінця списку. Ось як це виглядає на практиці:
'''
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
copy_numbers = numbers[:]
print(copy_numbers)
'''''
У цьому випадку copy_numbers є повною копією numbers. Зріз [:] вказує на вибір усіх елементів зі списку, починаючи з першого і закінчуючи останнім. Це створює новий список, який містить усі елементи оригінального списку, але є незалежним об'єктом. Якщо ти зміниш copy_numbers, це не вплине на numbers, і навпаки.

Зрізи — це надзвичайно корисний інструмент для роботи з послідовностями в Python, вони дозволяють легко й інтуїтивно отримувати підпослідовності або змінювати порядок елементів.
'''



###### Лекція 1. вт 25.02.2025. Тема 1. Вступ до Python (лектор Сергій Коденко)


print("Hello, world")

a=2
b=3
print(type(a))

a+=5 # a збільшити на 5
print(a) 

s1 = "hello "
s2 = "world"
a = s1*3 + s2
print(a)

# приведення типів

s1 = "2"
s2 = int("5")
a = int(s1)*3 + s2
print(a)

a = str(a)
print(a)
print(type(a))

# інструкції та вирази

b=5      # інструкція (один завершиний крок вашої програми), вираз - рядок в якому задаємо значення змінної або щось рахуємо
a=3+4    # інструкція (один завершиний крок вашої програми), вираз - рядок в якому задаємо значення змінної або щось рахуємо
b+=a     # інструкція (один завершиний крок вашої програми), вираз - рядок в якому задаємо значення змінної або щось рахуємо
print(b) # інструкція (один завершиний крок вашої програми)

с = 6; w=3

# колекції
# 1. Список
lst=[1,2,3,'a',"b",True, ['q',0] ] # list
lst[2] = 4
print(lst)
print(lst[-3])
print(type(lst))
lst.append(1)
print(lst)
lst.remove(1)
print(lst)
lst.remove(1)
print(lst)

# print(lst[-1][0])


#   True    False 
#   1000    0      # значення які приводяться до True та False
#   'asd'   ''     # значення які приводяться до True та False
#           None   # значення які приводяться до True та False

i = lst.pop()
print(i)

a = len(lst)
print(lst[a-1])

# 2. Кортеж
tpl = (1,2,3,'a',"b",True, ['q',0]) # tuple()
print(tpl)

tpl = tuple(lst)
#tpl[0] = 4 # Type Error бо кортеж не змінний
tpl[-1][0] = 10
print(tpl)

# 3. Set - множини - приведення значень до унікального переліку
tpl = (1,2,3,'a',"b",True)
st = set(tpl) # set не може працювати (містити в собі) зі змінними колекціями - списками, словниками
st = {1,2,3,4,4,3,2,1,3,4}
print(st)
print(type(st))
st.add(5)
st.add(5)
print(st)

# 4. Frozen set
st = frozenset((1,2,3,4,4,3,2,1,3,4, 'a', 'a'))
#st.add(5) # Attribute Error не можемо додавати 

# 5. Словник - колеція з пар ключ-значення
dictt = {'name': 'John', 
         'age': 30, 
          0: "sdawad",} # можна лишати кому в кінці словника
print(type(dictt))

dictt['mail'] = 'john@mail.com'
print(dictt)
dictt['age'] = 50
print(dictt)

print(dictt.keys())
print(dictt.values())
print(dictt.items())


a=[1,2,3]
b=a
print(a)
print(b)
b[1] = 5
print(a)
print(b)

t = ([1,2,3], 4, 5)
t[0][2]=5
print(t)

a=[1,2,3, [1,2,3]]
b=a.copy()
print(a)
print(b)
b[1] = 5
print(a)
print(b)

# зрізи (slices)

l = [1,2,3,4,5,6,7,8,9,0]
s = 'Hello World'
print(s[2:5])
print(s[2:7])
print(l[1:3])
print(l[1:7])
print(l[:])
print(l[5:])
print(l[:5])
print(l[1:8:2]) # кожен 2-й елемент (start incl : end excl : step)
print(l[1:8:3]) # кожен 3-й елемент
print(l[1:8:4]) # кожен 4-й елемент
print(l[0:8:2])
print(l[4:-2])
print(l[-2:4:-1]) # розвертаємо список у зворотньому порядку по аналогії з reverse()

start = 2
end = -2
step = 1

print(l[start:end:step])

l1 = l[::] # баянистий спосіб скопіювати список аналогія до copy()
print(l)
print(l1)
l1 [4] = 10
print(l)
print(l1)


# рядки

s = "Hello shiny world!"
#s[2] = 'w' # помилка
print(s[1])
print(s[1:2])
print(s.lower())
print(s.upper())
print(s.capitalize())
print(s.split()) # розділяємо рядок на частини по пробілу (окремі елементи) - отримуємо список
print(s.split('o')) # розділяємо рядок на частини по "o"
print(s.split('o')[2])
l = s.split()
print('_'.join(l))

print(s.isupper())
print(s.isalpha())
s = "Hello1shiny2world!"
print(s.isalnum())
print(s.isalnum())

s = "_w"
print(s.isidentifier())
s = "w"
print(s.isidentifier())

s = "tex ASCII 123"
print(s.isascii())

s = "tex ASCII 123 це не Аскі"
print(s.isascii())

a = bool(1)
print(a)


#### Питання - відповідь
# Питання 1 : Python - це процедурне та ООП програмування. прошу надати приклади обох методів. JavaScript - теж підтримує 2 моделі програмування?
# Відповідь:

#Python надзвичайно універсальний:
#Функціональна парадигма
from functools import reduce
reduce(lambda x,y:x+y, map(lambda x: x*x, range(10)))

#Процедурна парадигма
def greet():
    2+2==4
    print("Hello, world!")
greet()

#ООП парадигма
class Greeter:
    def __init__(self):
        self.text="Hello, world!"
    def hello(self):
        return self.text

g = Greeter()
print(g.hello())

#Декларативна парадигма
numbers = [1, 2, 3, 4, 5]
squared = [x * x for x in numbers]
print(squared)  # [1, 4, 9, 16, 25]

# Питання 2 : приклад conplex_number = 3.3 -2j - як використовується?
# Відповідь: Якщо не знаєте що таке комплексні числа - то краще й не треба, загалом є опис на вікі 
# Двома словами - це число, що має дійсну частину та уявну. 
# j - уявна одиниця, дорівнює кореню з -1. 
# Таким чином, корінь з -9 буде 3j.


