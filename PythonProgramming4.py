############# Тема 4. Регулярні вирази та розширена робота з рядками

'''
Регулярні вирази та розширена робота з рядками
Ми вже вивчили базову роботу з рядками у Python. Ви вмієте створювати рядки, об'єднувати рядки, міняти регістр рядків, перевіряти, що рядок закінчується або починається деякою послідовністю. Але можливості Python по роботі з рядками не вичерпуються цим. На цьому зайнятті ми дізнаємося більше про те, як працювати з рядками у Python, про роботу з регулярними виразами та перетвореннями рядків.



Варіанти створення рядків

Для створення рядків можна скористатися одинарними або подвійними лапками:



this_is_string = "Hi there!"

the_same_string = 'Hi there!'

this_is_string == the_same_string# True




Але що робити, якщо нам потрібен текст із перенесенням рядків (коли в тексті більше одного рядка)? Для цього можна скористатися потрійним повторенням лапок:

'''

text = """This is first line
And second line
Last third line"""

song = '''Jingle bells, jingle bells
Jingle all the way
Oh, what fun it is to ride
In a one horse open sleigh'''

'''


В цьому прикладі змінна text містить три рядки, а song — чотири рядки.



Коли інтерпретатор виявляє лапки, повторені тричі, він сприймає усі символи до наступних трьох лапок, які закривають рядок, як символи рядка.



Зворотна ситуація, у вас є довгий рядок, який не повинен містити перенесень, але в коді його незручно відобразити одним рядком.



one_line_text = "Textual data in Python is handled with str objects, or strings. Strings are immutable sequences of Unicode code points. String literals are written in a variety of ways: single quotes, double quotes, triple quoted."



Щоб структурувати код і не додавати зайвих перенесень, ви можете розбити одну рядкову змінну на декілька частин:



one_line_text = "Textual data in Python is handled with str objects," \
                " or strings. Strings are immutable sequences of Unicode" \
                " code points. String literals are written in a variety " \
                " of ways: single quotes, double quotes, triple quoted."



Зверніть увагу на символ \ в кінці першого та другого рядка коду, він вказує інтерпретатору ігнорувати закінчення рядка і продовжити відразу з наступного.



Змінна one_line_text в обох прикладах буде містити один і той самий текст без перенесень.



У Python, коли ви поміщаєте два рядкових літерали поруч, вони автоматично конкатенуються (об'єднуються в один рядок). Це відомо як неявна конкатенація рядків:



("spam " "eggs") == "spam eggs"  # True



Вираз ліворуч та вираз праворуч — це два рівнозначні записи одного і того самого тексту 'spam eggs' і, з погляду Python, — вони нерозрізнені. У нашому випадку, "spam " та "eggs" - це два окремих рядкових літерала, але коли вони розміщені один за одним без оператора додавання (+), Python автоматично об'єднує їх у один рядок.



Ця особливість часто використовується для зручності, особливо при написанні довгих рядків і тому змінну one_line_text можна записати наступним чином.



one_line_text = ("Textual data in Python is handled with str objects,"
                " or strings. Strings are immutable sequences of Unicode"
                " code points. String literals are written in a variety "
                " of ways: single quotes, double quotes, triple quoted.")



Неявна конкатенація рядків - це корисна особливість мови Python, яка дозволяє писати більш чистий і читабельний код, особливо коли працюєте з довгими рядками або рядками, що формуються на основі декількох частин.



Наприклад, в майбутньому, це дуже допомагає при створенні SQL запитів до бази даних:



query = ("SELECT * "
         "FROM some_table "
         "WHERE condition1 = True "
         "AND condition2 = False")





Спеціальні символи

Спеціальні символи в рядках у Python, відомі також як екрановані символи або escape-символи, використовуються для представлення певних керувальних послідовностей або для включення символів, які не можна ввести безпосередньо у рядок коду.



Ці символи починаються з оберненої косої риски (backslash, \), після якої йде один або кілька символів, що визначають спеціальну послідовність. Це означає, що наступний за ним знак потрібно сприймати як спеціальний символ, а не буквально.



Ось основні керувальні символи які необхідно знати:








Наприклад, символ \n відповідає за перенос рядка (line break).



✂️ Цей код можна запустити!

print("Hello\nWorld")



Виведення буде слово після символу \n з нового рядка:



Hello
World



Інший приклад — горизонтальна табуляція \t (tab):



✂️ Цей код можна запустити!

print("Hello\tWorld")



При виведенні між словами буде символ табуляції:

 Hello	World



Приклад для повернення каретки \r (carriage return).



✂️ Цей код можна запустити!

print("Hello my little\rsister")



Виведення відбувається наступним чином: коли ми зустрічаємо символ \r, то повертаємося на початок рядка і продовжуємо виведення. Це перезаписує попередній вивід:



sistermy little



Керувальний символ \b забій (backspace).



✂️ Цей код можна запустити!

print("Hello\bWorld")



Виведення здійснюється на один символ вліво та виконує вивід залишку після керувального символу.



HellWorld



Також якщо нам треба виконати виведення зворотної косої риски.



✂️ Цей код можна запустити!

print("Hello\\World")



Виведення:



Hello\World



Щоб екранувати одинарні та подвійні лапки та дозволити використовувати лапки всередині рядкових літералів.



✂️ Цей код можна запустити!

print('It\'s a beautiful day')
print("He said, \"Hello\"")



Виведення:

It's a beautiful day
He said, "Hello"



Ці спеціальні символи часто використовуються для форматування тексту в рядках, управління виводом у консолі або терміналі, а також при роботі з даними у форматі Unicode. Вибирайте ту форму запису, яка більше підходить під конкретну ситуацію, і керуйтеся зручністю для запису і читання коду, який містить рядкову змінну.

Методи рядків

Ми вже познайомилися з деякими методами рядків. Зараз розберемо методи, пов'язані з пошуком в рядках і створенням нових рядків.



Пошук у рядку

Для пошуку деякого символу або підрядка у рядку можна скористатися методом find:



✂️ Цей код можна запустити!

s = "Hi there!"

start = 0
end = 7

print(s.find("er", start, end)) # 5
print(s.find("q")) # -1



Виведення:

5
-1



Цей метод повертає індекс початку першого збігу в рядку s, починаючи з позиції start до позиції end. Якщо start та end не вказані, то пошук відбувається з початку і до кінця рядку. Метод повертає -1, якщо послідовність не знайдена.




Ще один метод пошуку підрядка у рядку дуже схожий на find — це index. Основна відмінність полягає в тому, що якщо index не знайде підрядок, то викличе виняток ValueError.



Якщо вам потрібно здійснити пошук підрядка у рядку справа, а не зліва як у find, то для цього існує метод rfind:



✂️ Цей код можна запустити!

s = 'Some words'

print(s.find("o"))
print(s.rfind('o'))



Вираз s.find("o") поверне 1, а вираз s.rfind('o') поверне 6 бо шукає справа рядка і матимемо наступне виведення:



1
6




І "правий" аналог index — rindex:



✂️ Цей код можна запустити!

s = 'Some words'

print(s.index("o"))
print(s.rindex('o'))



Виведення:

1
6





Поділ та об'єднання рядків

Часта ситуація, коли необхідно розбити рядок на підрядки за деяким символом, наприклад, розбити текст на речення за символом крапки та пробілу після крапки, або речення за словами.



Метод split() у Python використовується для розбиття рядка на список підрядків на основі вказаного роздільника. Якщо роздільник не вказаний, за замовчуванням використовується пробіл.



Синтаксис методу split()



str.split(separator=None, maxsplit=-1)



де:



separator - роздільник, за яким слід розділяти рядок. Якщо не вказано, рядок розділяється за будь-яким пробілом.
maxsplit - максимальна кількість розділень. Значення -1 означає "без обмежень".


Розглянемо приклад



✂️ Цей код можна запустити!

text = "hello world"
result = text.split()
print(result)  # Виведе: ['hello', 'world']



Виведення:

['hello', 'world']



У цьому прикладі рядок "hello world" розділяється на список з двох елементів: 'hello' та 'world' за пробілом.



Якщо ми хочемо розділити рядок вказаним роздільником то:



✂️ Цей код можна запустити!

text = "apple,banana,cherry"
result = text.split(',')
print(result)  # Виведе: ['apple', 'banana', 'cherry']



Тут рядок розділяється за комами і виведення буде наступним:



['apple', 'banana', 'cherry']



Метод split() широко використовується для обробки текстових даних, розбору користувацького вводу, читання даних з файлів та інших завдань, де потрібно розбити рядок на складові частини за певним критерієм. Це основний інструмент для роботи з рядками в Python.



Усі рядки незмінні, і якщо ми хочемо модифікувати рядок, є тільки один спосіб — створити новий рядок на основі вихідного. Усі методи, які якось "модифікують" рядки, насправді повертають нові рядки, ніяк не змінюючи оригінальний.



Метод join() у Python використовується для об'єднання послідовності рядків (наприклад, списку або кортежу) в один рядок з використанням вказаного роздільника. Цей метод викликається на рядковому об'єкті, який служить роздільником:



Синтаксис методу join()

string.join(iterable)



де:



string - рядок роздільник, який буде вставлений між елементами послідовності.
iterable - послідовність, список або кортеж рядків, які потрібно об'єднати.


По суті метод join(), є зворотною операцією до методу split.



Розглянемо типовий приклад



✂️ Цей код можна запустити!

list_of_strings = ['Hello', 'world']
result = ' '.join(list_of_strings)
print(result)  # Виведе: 'Hello world'



У цьому прикладі список ['Hello', 'world'] об'єднується в один рядок з пробілом як роздільником і на виході в змінній result ми отримаємо рядок 'Hello world'.



Використаємо різні роздільники, як наприклад ', ' - це кома та пробіл.



✂️ Цей код можна запустити!

elements = ['earth', 'air', 'fire', 'water']
result = ', '.join(elements)
print(result)  # Виведе: 'earth, air, fire, water'



Тут рядки із списку elements об'єднуються з комою і пробілом як роздільниками.



Виведення буде наступним:

earth, air, fire, water



Якщо потрібно видалити зайві пробіли на початку і в кінці рядка, є спеціальний метод strip:



✂️ Цей код можна запустити!

clean = '   spacious   '.strip()
print(clean) # spacious



Виведення буде рядок "spacious" без пробілів зліва та права.



У цього метода є два "брати":



"лівий", lstrip, видаляє тільки пробіли на початку рядка;
та "правий", rstrip, видаляє тільки пробіли в кінці рядка.


Коли ж нам потрібно замінити деякий підрядок в рядку, ми можемо скористатися методом replace. Метод replace() у Python використовується для заміни підрядка на інший підрядок у рядку. Цей метод повертає новий рядок, де кожне входження вказаного підрядка замінено на інший підрядок.



Метод replace() має наступний синтаксис



str.replace(old, new, count=-1)



де:



old - підрядок, який потрібно замінити.
new - підрядок, на який потрібно замінити.
count - лічильник максимальної кількості замін. Якщо не вказано або вказано -1, замінюються всі входження.


Розглянемо приклад, який в рядку "Hello world" слово "world" замінює на слово "Python".



✂️ Цей код можна запустити!

text = "Hello world"
new_text = text.replace("world", "Python")
print(new_text) 



Виведення:

Hello Python



Якщо нам треба обмеження кількості замін, то:



✂️ Цей код можна запустити!

text = "one fish, two fish, red fish, blue fish"
new_text = text.replace("fish", "bird", 2)
print(new_text)  



Тут метод replace() замінює перші два входження слова "fish" на слово "bird".



one bird, two bird, red fish, blue fish



Метод replace() також застосовують для видалення підрядка



✂️ Цей код можна запустити!

text = "Hello, world!"
new_text = text.replace(" world", "")
print(new_text)



У цьому прикладі підрядок " world" видаляється з рядка. Виведення:



Hello,!



Загалом метод replace() широко використовується для обробки тексту в Python.



Та може бути корисним коли необхідно:



Виправлення помилок у тексті
Заміну специфічних символів або слів
Форматування даних для виводу
Видалення або заміна чутливих даних перед виводом або збереженням


Цей метод також є одним з основних інструментів для роботи з рядками в Python, дозволяючи легко і швидко змінювати вміст рядків.



Для видалення фіксованої послідовності на початку рядка є метод removeprefix:



✂️ Цей код можна запустити!

print('TestHook'.removeprefix('Test')) # Hook
print('TestHook'.removeprefix('Hook')) # TestHook



Виведення, в першому випадку 'Test' є префіксом рядка та буде видалений, в другому 'Hook' це суфікс рядка і видалений не буде:



Hook
TestHook



Є парний метод для видалення послідовності в кінці рядка, removesuffix:



✂️ Цей код можна запустити!

print('TestHook'.removesuffix('Test'))
print('TestHook'.removesuffix('Hook'))



Виведення, тут зворотна ситуація і вже видаляється 'Hook':

TestHook
Test



Розглянемо наступну задачу та використаємо основні інструменти для роботи з рядками - методи split() та replace(). Ви маєте URL пошукового запиту, і ваше завдання - видобути та обробити параметри цього запиту. Наприклад пошуковий запит "Cat and dog"



<https://www.google.com/search?q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t>



Параметри в URL зазвичай слідують після символу ? та розділені символами &. Кожен параметр складається з ключа та значення, розділених символом =.



Нам треба написати код, який обробляє URL пошукового запиту, щоб видобути параметри запиту та перетворити їх у формат, з яким легше працювати в Python. Коли ви вводите пошуковий запит у браузері, він формує URL, де ваш запит та інші налаштування кодуються як ряд параметрів. Наш код повинен "розпаковувати" ці параметри, перетворюючи їх на словник Python, де ми можемо легко отримати доступ до кожного параметра за його ім'ям.



Тож почнемо. Спочатку нам треба отримати частини запиту з URL:



✂️ Цей код можна запустити!

url_search = "<https://www.google.com/search?q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t>"
_, query = url_search.split('?')
print(query)



Виведення:

q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t



Змінна url_search - це наш початковий URL. Далі операція url_search.split('?') розділяє URL на дві частини: до знаку ? та після. Оскільки нас цікавить лише частина після ?, ми використовуємо символ _ для ігнорування частини URL до ?. Та отримуємо змінну query яка рядок, що містить необхідні нам параметри запиту.



Далі ми додамо до нашого коду обробку параметрів запиту:



✂️ Цей код можна запустити!

url_search = "<https://www.google.com/search?q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t>"
_, query = url_search.split('?')
print(query)

obj_query = {}
for el in query.split('&'):
    key, value = el.split('=')
    obj_query.update({key: value.replace('+', ' ')})
print(obj_query)



Виведення:

q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t
{'q': 'Cat and dog', 'ie': 'utf-8', 'oe': 'utf-8', 'aq': 't'}



Давайте розбиратися, що тут відбувається. Ми створюємо порожній словник obj_query для зберігання параметрів запиту. Вираз query.split('&') розділяє рядок на окремі параметри за символом & та формує наступний список ['q=Cat+and+dog', 'ie=utf-8', 'oe=utf-8', 'aq=t']. В середині циклу, кожен параметр el містить ключ та значення, розділені символом =. Спочатку ми розділяємо кожен параметр el на ключ та значення key, value = el.split('=').

Вираз obj_query.update({key: value.replace('+', ' ')}) додає пару ключ-значення до словника obj_query. Але ми ще виконуємо value.replace('+', ' ') і замінює символи + на пробіли, оскільки у URL пробіли зазвичай кодуються як +. Після завершення циклу виводиться оброблений словник obj_query, де ключі та значення відповідають параметрам запиту.



Такий підхід часто використовується у веб-розробці та обробці даних для роботи з інформацією, отриманою з інтернет-запитів.



Останній метод який ми розглянемо це isdigit(). Він використовується для перевірки, чи складається рядок повністю з цифр. Цей метод повертає True, якщо всі символи в рядку є цифрами та рядок складається принаймні з одного символу, інакше повертає False.



✂️ Цей код можна запустити!

number = "12345"
print(number.isdigit())  # Виведе: True

text = "Number123"
print(text.isdigit())  # Виведе: False



У цьому прикладі, isdigit() повертає True для рядка "12345", оскільки він складається виключно з цифр. Для рядка "Number123", метод повертає False, оскільки він містить інші символи, крім цифр.



Можна застосовувати для перевірки, чи ввів користувач число.



✂️ Цей код можна запустити!

user_input = input("Введіть число: ")
if user_input.isdigit():
    print("Це дійсно число!")
else:
    print("Це не число!")



Виконувати перевірку на цифрові символи в рядку.



✂️ Цей код можна запустити!

for char in "Hello 123":
    if char.isdigit():
        print(f"'{char}' - це цифра")
    else:
        print(f"'{char}' - не цифра")



Цей код перевіряє кожен символ в рядку та друкує, чи є цей символ цифрою.



Виведення:

'H' - не цифра
'e' - не цифра
'l' - не цифра
'l' - не цифра
'o' - не цифра
' ' - не цифра
'1' - це цифра
'2' - це цифра
'3' - це цифра

Метод translate()



Метод translate() в Python використовується для перетворення рядків шляхом заміни певних символів іншими символами. Цей метод дозволяє вам вказати, які саме символи слід замінити та на що замінити, використовуючи так звану "таблицю перекладу" - спеціальний словник, що визначає відображення замін.



Тому перш ніж використовувати translate(), нам потрібно створити таблицю перекладу. Це можна зробити за допомогою методу str.maketrans(), який приймає два аргументи:



Рядок символів, які потрібно замінити.
Рядок символів, на які потрібно замінити.


Довжина обох рядків має бути однаковою, оскільки вони визначають взаємну відповідність символів.



Розглянемо приклад використання translate():



✂️ Цей код можна запустити!

intab = "aeiou"
outtab = "12345"
trantab = str.maketrans(intab, outtab)

str = "This is string example"
print(str.translate(trantab))



У цьому прикладі всі голосні літери 'a', 'e', 'i', 'o', 'u' у рядку замінюються відповідно на числа '1', '2', '3', '4', '5'. Результатом виконання коду буде рядок "Th3s 3s str3ng 2x1mpl2".



Метод translate() також може використовуватися для видалення певних символів із рядка. Для цього передайте в maketrans() третій аргумент - рядок символів, які потрібно видалити.



✂️ Цей код можна запустити!

intab = "aeiou"
trantab = str.maketrans('', '', intab)

str = "This is string example"
print(str.translate(trantab))



Цей приклад видаляє всі голосні літери з рядка, виводячи рядок "Ths s strng xmpl" без голосних.



Метод може бути використаний для різноманітних завдань з обробки тексту. Нормалізація тексту, це коли треба замінити або видалити специфічні символи. Операції кодування та декодування - створення простих кодувань шляхом заміни символів. Фільтрація тексту шляхом видалення небажаних символів, наприклад, пунктуації або цифр.



Метод є чудовим вибором для складніших завдань з обробки та трансформації рядків. Розглянемо пару більш складних задач.



Наприклад нам треба розробити програму, яка конвертує рядок, що містить шістнадцяткові числа (в якості окремих символів), у відповідний двійковий код.



Програма повинна обробляти як великі, так і малі літери шістнадцяткових чисел і перетворювати кожен символ на його чотирибітове двійкове представлення.



✂️ Цей код можна запустити!

symbols = "0123456789ABCDEF"
code = [
        '0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
        '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'
        ]

MAP = {}

for s, c in zip(symbols, code):
    MAP[ord(s)] = c
    MAP[ord(s.lower())] = c

result = "34 DF 56 AC".translate(MAP)
print(result)



Спочатку ми виконуємо ініціалізацію даних:



symbols = "0123456789ABCDEF"
code = [
        '0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
        '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'
        ]



Де:



symbols - рядок, що містить символи, які будуть перетворюватися.
code - список рядків з двійковим кодом, який відповідає кожному символу в symbols.


В даному конкретному випадку використання str.maketrans() для створення

таблиці перекладу не буде таким же ефективним, як вручну створена таблиця перекладу. Для створення таблиці ми використаємо словник MAP. Для цього ми використовуємо zip(symbols, code), який створює пари символ-двійковий код.



Далі цикл for проходить по цих парах, додаючи в MAP відповідність між Unicode кодом символу, за допомогою функції ord(s) та його двійковим кодом c. Для кожного символу додається як його верхній, так і нижній регістр s.lower().



MAP = {}

for s, c in zip(symbols, code):
    MAP[ord(s)] = c
    MAP[ord(s.lower())] = c



В нашому випадку ми отримаємо наступну таблицю перекладу MAP:



{
    48: "0000",
    49: "0001",
    50: "0010",
    51: "0011",
    52: "0100",
    53: "0101",
    54: "0110",
    55: "0111",
    56: "1000",
    57: "1001",
    65: "1010",
    97: "1010",
    66: "1011",
    98: "1011",
    67: "1100",
    99: "1100",
    68: "1101",
    100: "1101",
    69: "1110",
    101: "1110",
    70: "1111",
    102: "1111",
}



Де ключ це Unicode для символів "0123456789ABCDEF" в верхньому та нижньому регістрі, а значення відповідні елементи списку code.



☝ Функція ord() в Python - це вбудована функція, яка використовується для отримання Unicode коду символу. Коли ви працюєте з текстом в Python, кожен символ у рядку має відповідний числовий код - Unicode. Функція ord() приймає символ і повертає його Unicode код, який є цілим числом.


Далі ми використовуємо метод translate() для перетворення рядка "34 DF 56 AC" відповідно до нашої таблиці перекладу MAP. Метод кожен символ у вихідному рядку замінює на його двійкове представлення згідно з MAP.



result = "34 DF 56 AC".translate(MAP)
print(result)



Коли цей код виконується, він перетворює кожен символ у "34 DF 56 AC" в його відповідник у двійковому коді, використовуючи MAP. Це виведе двійкове представлення кожного шістнадцяткового символу.



00110100 11011111 01010110 10101100



Наступний приклад, це розробити програму, яка перетворює вхідний текстовий рядок на відповідний код мови Морзе.



✂️ Цей код можна запустити!

morze_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
              'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
              'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
              'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
              'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',
              '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
              '8': '---..', '9': '----.'}

# Перетворення ключів словника на Unicode коди
table_morze_dict = {}
for k, v in morze_dict.items():
    table_morze_dict[ord(k)] = v

string = "Hello world"

result = ""

for ch in string:
    result = result + ch.upper().translate(table_morze_dict)

print(result)



Словник morze_dict, де ключами є латинські літери та цифри, а значеннями - відповідні коди у мові Морзе. З цього словника нам треба створити таблицю перекладу table_morze_dict, тому цей фрагмент коду відповідає саме за це:



table_morze_dict = {}
for k, v in morze_dict.items():
    table_morze_dict[ord(k)] = v



Цикл for проходить по кожному елементу словника morze_dict та для кожного ключа словника morze_dict використовуючи функцію ord(k) додає до словника table_morze_dict Unicode ключі та відповідні коди Морзе - значеннями.



Далі ми перетворюємо рядок string в рядок result але вже азбукою Морзе.



✂️ Цей код можна запустити!

string = "Hello world"

result = ""

for ch in string:
    result = result + ch.upper().translate(table_morze_dict)

print(result)



Ми виконуємо ініціалізацію змінної result для зберігання результату. Після цикл for проходить по кожному символу рядка string. За допомоги методу ch.upper() перетворюємо символ у верхній регістр, щоб відповідати ключам у таблиці table_morze_dict. Метод translate(table_morze_dict) використовується для заміни кожного символу його відповідником у мові Морзе згідно з таблицею table_morze_dict. Результат додається до result.



В кінці виконання коду змінна result містить перетворений рядок у мові Морзе, який виводиться на екран.



......-...-..--- .-----.-..-..-..



Який висновок можна зробити? Метод translate() є потужним інструментом, який пропонує більш гнучкі можливості порівняно з методом replace(), особливо коли вам потрібно зробити багато різних замін у одному рядку.

Форматування рядків



Будь-яке число можна записати кількома варіантами запису:

десятковий запис
двійкове представлення
шістнадцяткове представлення
наукова нотація
з фіксованою точністю (кількістю знаків після коми)
та інші.



Наприклад, вивести числа від 1 до 15 в десятковому, шістнадцятковому, вісімковому і двійковому представленні можна наступним чином:



✂️ Цей код можна запустити!

for i in range(8):
    s = f"int: {i:d};  hex: {i:#x};  oct: {i:#o};  bin: {i:#b}"
    print(s)



Виведення:

int: 0;  hex: 0x0;  oct: 0o0;  bin: 0b0
int: 1;  hex: 0x1;  oct: 0o1;  bin: 0b1
int: 2;  hex: 0x2;  oct: 0o2;  bin: 0b10
int: 3;  hex: 0x3;  oct: 0o3;  bin: 0b11
int: 4;  hex: 0x4;  oct: 0o4;  bin: 0b100
int: 5;  hex: 0x5;  oct: 0o5;  bin: 0b101
int: 6;  hex: 0x6;  oct: 0o6;  bin: 0b110
int: 7;  hex: 0x7;  oct: 0o7;  bin: 0b111



Форматування за допомогою виразів у f-рядках дозволяє не тільки вставляти значення змінних у рядок, а й форматувати ці значення за допомогою спеціальних вказівок.



Наприклад:



✂️ Цей код можна запустити!

price = 19.99
quantity = 3
total = f"Total: {price * quantity:.2f}"
print(total)



В цьому прикладі використовується форматування :.2f для відображення дійсного числа з двома цифрами після десяткового розділювача. Виведення:



Total: 59.97



У виразі :.2f:

: вводить специфікацію формату.
.2 означає, що після десяткової крапки має бути виведено дві цифри.
f вказує на формат дійсного числа.


Цей формат дуже корисний при виведенні грошових сум, наукових даних, або будь-яких інших чисел, де потрібна точність до певного числа знаків після коми.



Крім того, при створенні рядків буває корисним відформатувати рядок так, щоб знаки на різних рядках були один під одним (додати пробілів), додати заповнення в рядки для того, щоб результат був завжди однієї і тієї самої довжини. Або вивести квадрати та куби чисел до 12 у вигляді таблиці, відцентрувавши значення у стовпцях по 10 символів шириною:



✂️ Цей код можна запустити!

width = 5
for num in range(12):
    print(f'{num:^10} {num**2:^10} {num**3:^10}')



Виведення:

    0          0          0     
    1          1          1     
    2          4          8     
    3          9          27    
    4          16         64    
    5          25        125    
    6          36        216    
    7          49        343    
    8          64        512    
    9          81        729    
    10        100        1000   
    11        121        1331



Мета роботи з метамовою форматування полягає у зазначенні в фігурних дужках, яким чином варто перетворити значення перед тим як підставити його в рядок.



Вирівнювання та ширина поля в f-рядках в Python дозволяють контролювати, як текст або числа відображаються у рядку, включаючи вирівнювання (ліворуч, праворуч, по центру) та загальну ширину поля, яка використовується для відображення вмісту. Ці можливості особливо корисні, коли вам потрібно створити впорядкований, охайний текстовий вивід.



Ширина поля вказує мінімальну ширину поля, в яке буде поміщено вміст. Якщо вміст коротший за ширину поля, він буде доповнений пробілами.



Вирівнювання визначає, як вміст буде вирівняний всередині вказаної ширини поля. Можливі варіанти вирівнювання:



<: Вирівнювання вмісту по лівому краю.
>: Вирівнювання вмісту по правому краю.
^: Вирівнювання вмісту по центру.
=: Використовується для вирівнювання чисел, при цьому знак (якщо він є) відображається зліва, а число - по правому краю поля.


Наприклад:



✂️ Цей код можна запустити!

name = "Alice"
formatted = f"{name:>10}"
print(formatted)  # Виведе: '     Alice' (вирівнювання праворуч)



Виведення з 5-ма пробілами ліворуч.

     Alice



☝ Форматування спочатку було зроблено для методу format, який приймає аргументи, як значення для щоб підставити їх в рядок, замість виразів у фігурних дужках.


Також корисним є форматування відсотків за допомогою f-рядків, що дозволяє зручно відображати числа як відсотки. Для цього використовується специфікатор формату %, який множить число на 100 і додає символ відсотка % до рядка. Це особливо корисно при роботі з даними, де потрібно представляти частки або пропорції у форматі відсотків.



Форматування відсотків у f-рядках виглядає так:



f"{value:<ширина>.<точність>%}"



де:

value - значення, яке потрібно перетворити у відсотки.
<ширина> - загальна ширина поля; необов'язково.
<точність> - кількість знаків після десяткової крапки; необов'язково.


Наприклад:



✂️ Цей код можна запустити!

completion = 0.756
formatted = f"{completion:.1%}"
print(formatted)  # Виведе: '75.6%'



Тут число 0.756 перетворюється на '75.6%', де .1 вказує на вивід однієї цифри після десяткової крапки. Виведення:



75.6%



Приклад без десяткових частин:



✂️ Цей код можна запустити!

progress = 0.5
formatted = f"{progress:.0%}"
print(formatted)



У цьому випадку число 0.5 перетворюється на '50%', без додаткових десяткових знаків.



Виведення:

50%



Це досить широка тема і для таких та подібних завдань в Python вбудована своя міні-мова форматування рядків з якою ви можете ознайомитися далі самостійно.

Регулярні вирази



Регулярні вирази (regular expressions, часто скорочують як regex або regexp) - це потужний інструмент для роботи з текстом, який дозволяє шукати, замінювати або витягувати певні шаблони в тексті за допомогою спеціального синтаксису. Регулярні вирази широко використовуються в програмуванні, обробці тексту, а також у різних програмах та інструментах для роботи з даними.



Основні компоненти регулярних виразів включають:

Літерали. Пряме відображення символів (наприклад, a, B, 1).
Метасимволи. Символи, які мають спеціальне значення в регулярних виразах (наприклад, . (крапка) відповідає будь-якому символу).
Квантифікатори. Визначають, скільки разів елемент повинен відповідати (наприклад * означає 0 або більше повторень).
Класи символів. Визначають групи символів (наприклад, [a-z] відповідає будь-якій малій літері).
Групи та діапазони. Використовуються для групування частин виразу (наприклад, (abc) визначає групу символів).
Альтернації. Відповідає одному з декількох шаблонів (наприклад, a|b відповідає a або b).
Якорі. Визначають позиції у тексті (наприклад, ^ для початку рядка, $ для кінця рядка).


Регулярні вирази можуть бути досить складними, але вони надзвичайно потужні для розширеного пошуку та обробки тексту. Вони широко використовується у багатьох мовах програмування, а не тільки у Python.



Регулярні вирази дозволяють шукати певні шаблони в рядках, виконувати заміни, розбивати рядки на частини і багато іншого. Для роботи з регулярними виразами в Python використовується модуль re.



Основні функції модуля re які ми розглянемо далі це:

re.search(pattern, string) - виконує пошук першого входження шаблону в рядку.
re.findall(pattern, string) - виконує знаходження всіх входжень шаблону в рядку.
re.sub(pattern, repl, string) - виконує заміну входжень шаблону на інший рядок.
re.split(pattern, string) виконує розбивання рядка за шаблоном.


Основне завдання регулярних виразів — це пошук рядка, або підрядка, який відповідає опису в термінах регулярних виразів.



Використовуючи цей механізм можна робити наступні операції:

перевіряти, що рядок відповідає деяким вимогам (це номер телефону або email);
розділяти рядки на підрядки за деяким виразом (розбити текст на речення, використовуючи усі розділові знаки, а не тільки якийсь один);
замінювати підрядок в рядку (замінити усі слова, що починаються на деяку послідовність);
знаходити підрядок в рядку, який відповідає виразу.


Регулярні вирази знаходять застосування в багатьох областях, включаючи обробку тексту, валідацію даних, парсинг і скрапінг веб-сторінок, пошук і заміна в текстових редакторах та багато іншого. Вони є потужним інструментом для будь-якого програміста, який працює з текстовими даними.



Регулярний вираз або коротко "регулярка" складається зі звичайних символів і спеціальних командних послідовностей. Наприклад, \d задає будь-яку цифру, а \d+ — задає будь-яку послідовність з однієї або більше цифр. Це називається шаблони регулярних виразів.



Регулярні вирази використовують спеціальні символи для створення шаблонів. Вони складаються з блоків та модифікаторів.



Прикладом блоку може бути:

\w — будь-яка цифра або буква [a-zA-Z0-9_] (\W — все, крім букви або цифри [^a-za-z0-9_])
\d — будь-яка цифра [0-9] (\D — усе, крім цифри [^0-9])
\s — будь-який пробільний символ [\t\n\r\f\v] (\S — усе, крім пробільних символів [^\t\n\r\f\v])
\b — межа слова
[...] — один із символів у дужках ([^ ] — будь-який символ, крім тих, що в дужках)
^ і $ — початок і кінець рядка відповідно
( ) — групує вираз і повертає знайдений текст
\t, \n, \r — символ табуляції, нового рядка та повернення каретки


Модифікатори можуть вказувати на кількість повторень блоку у виразі, наприклад:



. — один будь-який символ, крім рядка \n
? — 0 або 1 входження шаблону зліва
+ — 1 і більше входжень шаблону зліва
* — 0 і більше входжень шаблону зліва
\ — екранування спец.символів (приклад: \. — означає крапку або \+ — знак "плюс")
{n} суворо n разів (n ціле число)
{n,m} — від n до m входжень (приклад: {,m} — від 0 до m)
a|b — відповідає a або b. Сам символ | означає "або" між двома шаблонами
( ) — групує вираз і повертає знайдений текст


Кожен з цих елементів дозволяє створювати гнучкі та потужні шаблони пошуку в тексті за допомогою регулярних виразів. Саме складання регулярних виразів — це дуже велика тема варта окремого вивчення. Але базові засади створення регулярних виразів ми з вами розберемо.



☝ Ось гарна стаття на тему регулярних виразів, там багато прикладів і корисних посилань.


Для роботи з регулярними виразами у Python є стандартний модуль re. Щоб скористатися цим модулем, його потрібно спочатку імпортувати:



import re



Загальним для усіх функцій модуля re є те, що першим аргументом йде регулярний вираз у вигляді рядка.





Метод search



Модуль re у Python надає інструменти для роботи з регулярними виразами. Одна з основних функцій цього модуля - re.search(), яка використовується для пошуку першого входження шаблону в рядку. Регулярний вираз - це шаблон, який використовується для знаходження певних комбінацій символів у рядках.



Синтаксис:



re.search(pattern, string)



pattern: Регулярний вираз (шаблон), який ви хочете знайти.
string: Рядок, у якому ви хочете знайти шаблон.


Результат виконання re.search() це спеціальний об'єкт Match, якщо знаходить відповідність. Якщо відповідність не знайдена, повертає None.



Об'єкт Match має властивості та методи, що використовуються для отримання інформації про пошук та результат:



Match.span() повертає кортеж, що містить початкову та кінцеву позиції збігу.
Match.string повертає рядок, переданий у функцію,
Match.group() повертає частину рядка, в якому був збіг


Ви можете використати метод .group() у цьому об'єкті, щоб отримати відповідну частину рядка.



Наприклад, виконаємо пошук слова "Python" у рядку.



✂️ Цей код можна запустити!

import re

text = "Вивчення Python може бути веселим."
pattern = "Python"
match = re.search(pattern, text)

if match:
    print("Знайдено:", match.group())
else:
    print("Не знайдено.")



У цьому прикладі ми шукаємо пряме входження слова "Python". Якщо знаходимо, виводимо знайдене слово. Виведення:



Знайдено: Python



Тепер використаємо метасимволи, та виконаємо пошук слова, що починається на "в" та закінчується на "м".



✂️ Цей код можна запустити!

import re

text = "Вивчення Python може бути веселим."
pattern = r"в\w*м"
match = re.search(pattern, text, re.IGNORECASE)

if match:
    print("Знайдено:", match.group())



Тут змінна pattern зберігає регулярний вираз r"в\w*м":

r означає "сирий" рядок (raw string), який каже Python ігнорувати спеціальні символи такі як \n, \t тощо, оскільки це рядок для регулярних виразів.
в - шукаємо слово яке починається на букву "в".
\w* - це означає будь-яка кількість букв включно з нулем букв. Бо \w відповідає будь-якому "словесному" символу, а * є квантифікатором, який означає "нуль або більше входжень попереднього елемента".
м - шукаємо слово яке закінчується на "м".


В функцію search ми передаємо параметр re.IGNORECASE, який робить пошук нечутливим до регістру. А отже слово може бути як з великих так і малих літер.



Виведення:

Знайдено: веселим



Розглянемо простеньку задачу - знаходження електронної адреси в рядку.



✂️ Цей код можна запустити!

import re

text = "Моя електронна адреса: example@example.com"
pattern = r"\w+@\w+\.\w+"
match = re.search(pattern, text)

if match:
    print("Електронна адреса:", match.group())



У цьому прикладі регулярний вираз \w+@\w+\.\w+ шукає електронну адресу:



\w+ - спочатку повинні йти одна або більше букв або цифр.
@ - далі обов'язково повинен бути символ @.
\w+ - після символу @ повинна йти ще одна серія букв.
\. - серія букв повинна закінчитись символом крапки. Ми екрануємо його, бо в регулярному виразі, крапка є модифікатором та має спеціальне значення.
\w+ - далі йде серія букв після крапки.


Отже функція re.search за цим шаблоном повинна знайти електронну адресу в рядку. Виведення:



Електронна адреса: example@example.com



Цей приклад демонструє регулярний вираз до складного шаблону, такого як електронна адреса. Але треба сказати, що “справжні” регулярні вирази для пошуку електронної адреси набагато складніші, ми використали мінімально необхідний.



Припустимо, у нас є рядок з електронною адресою, і ми хочемо вилучити ім'я користувача та домен цієї електронної адреси окремо. Треба розділити "username@domain.com" на "username" (ім'я користувача) та "domain.com" (домен).



Рішення:



✂️ Цей код можна запустити!

import re

email = "username@domain.com"
pattern = r"(\w+)@(\w+\.\w+)"
match = re.search(pattern, email)

if match:
    user_name = match.group(1)
    domain_name = match.group(2)
    print("Ім'я користувача:", user_name)
    print("Домен:", domain_name)



Виведення:

Ім'я користувача: username
Домен: domain.com



Давайте трошки зробимо пояснення, що тут відбулося. Головне це наш регулярний вираз (\w+)@(\w+\.\w+). Перші круглі дужки (\w+) відповідають одному або більше словесним символам. Це група збігається з ім'ям користувача електронної адреси. Далі в нас відбувається пошук @ - символ, що розділяє ім'я користувача та домен. Він нам не потрібний і в дужки ми його не беремо. Другі круглі дужки (\w+\.\w+) відповідають за домену електронної адреси. Тут \w+ збігається з першою частиною домену, \. - це крапка, і ще один \w+ для збігу з доменом верхнього рівня (наприклад, "com").



Коли re.search() знаходить відповідність, вона повертає об'єкт Match. Методи match.group(1) та match.group(2) використовуються для вилучення тексту, що відповідає кожній групі в шаблоні.



Цей приклад показує, як круглі дужки можуть бути корисними для групування та вилучення специфічних частин тексту в регулярних виразах.





Метод findall

Метод re.findall() використовується для знаходження всіх входжень шаблону, заданого регулярним виразом, у заданому рядку.



Синтаксис методу:

import re

matches = re.findall(pattern, string)



pattern - регулярний вираз, який ви шукаєте.
string - рядок, у якому потрібно знайти відповідності.


Метод повертає список всіх знайдених відповідностей. Якщо відповідностей не знайдено, повертається пустий список.



Розглянемо приклади використання методу для пояснення.



Необхідно знайти всі числа у рядку. Для цього нам знадобиться використання блоку \d, щоб знайти всі цифри в тексті.



✂️ Цей код можна запустити!

import re

text = "Рік 2023 був складнішим, ніж 2022"
pattern = r"\d+"
matches = re.findall(pattern, text)

print(matches)



У цьому прикладі регулярний вираз \d+ шукає одну або більше цифр у рядку підряд та знаходить їх, на виході ми отримуємо список всіх чисел в рядку.



Виведення:

['2023', '2022']



Необхідно зробити вибірку всіх слів в тексті. Тут буде в нагоді використання такого регулярного виразу \w+ для знаходження всіх слів у рядку. Ми використали блок \w, будь-яка цифра або буква та модифікатор +, це 1 і більше входжень шаблону зліва, нам потрібні слова в яких є хоч одна буква.



✂️ Цей код можна запустити!

import re

text = "Python - це проста, але потужна мова програмування."
pattern = r"\w+"
matches = re.findall(pattern, text)

print(matches)  # Виведе список всіх слів у рядку



Регулярний вираз \w+ відповідає за будь-яку послідовність літер, цифр або підкреслень тому виведення буде наступним:



['Python', 'це', 'проста', 'але', 'потужна', 'мова', 'програмування']

Останнім, для методу, розглянемо приклад знаходження електронних адрес. В рядку знаходиться декілька електронних адрес які необхідно добути.



Використання вже розглянутого нами регулярного виразу r"\w+@\w+\.\w+" може стати нам в нагоді.



✂️ Цей код можна запустити!

import re

text = "Контакти: example1@example.com, example2@sample.org"
pattern = r"\w+@\w+\.\w+"
matches = re.findall(pattern, text)

print(matches)  # Виведе всі знайдені електронні адреси



Але на це раз ми отримаємо список електронних адрес:



['example1@example.com', 'example2@sample.org']



Підсумуємо:



Метод re.findall корисний, коли вам потрібно зібрати всі відповідності регулярного виразу в рядку, наприклад, зібрати всі електронні адреси з тексту або всі слова, що задовольняють певному шаблону.
Цей метод часто використовується в задачах обробки тексту, де необхідно знайти і вилучити інформацію з великих обсягів тексту.




Метод sub



Метод re.sub() в модулі re Python використовується для заміни входжень регулярного виразу pattern в рядку string на рядок repl. Це дуже корисно для модифікації тексту.



Синтаксис:



import re

modified_string = re.sub(pattern, repl, string)



pattern - регулярний вираз, який вказує на частину рядка, яку потрібно замінити.
repl - рядок, на який буде замінено збіги.
string - рядок, в якому відбувається заміна.


Метод повертає рядок, у якому всі входження pattern замінені на repl.



Розглянемо приклад. У нас є назва файлу з пробілами, наприклад, "Мій документ Python.txt". Нам потрібно перетворити цю назву так, щоб замість пробілів були підкреслення, отримуючи "Мій_документ_Python.txt". І в майбутньому це прийдеться робить багато разів і нам хочеться автоматизувати цей процес.



Навіщо це і яка в цьому необхідність?



Перше, це уникнення проблем зі шляхами до файлів у операційних системах, які можуть неправильно обробляти пробіли.
Друге, спрощення доступу до файлів через командний рядок, де пробіли часто вимагають додаткового екранування.
Третє, забезпечуємо сумісність з URL, де пробіли не дозволені, якщо забажаємо віддавати цей файл с нашого сайту.


Та й взагалі пробіли в назві файлу для програміста моветон 😊.



Замінити всі пробільні символи на підкреслення.



✂️ Цей код можна запустити!

import re

file_name = "Мій документ Python.txt"
pattern = r"\s"
replacement = "_"
formatted_name = re.sub(pattern, replacement, file_name)

print(formatted_name)  



У цьому прикладі блок \s відповідає будь-якому пробільному символу, і він замінюється на _. Виведення:



Мій_документ_Python.txt



Чого ми й домагалися.



Видалимо всі пунктуаційні знаки з рядка.



✂️ Цей код можна запустити!

import re

text = "Python - потужна, універсальна; мова!"
pattern = r"[;,\-:!\.]"
replacement = ""
modified_text = re.sub(pattern, replacement, text)

print(modified_text)  



Тут регулярний вираз [;,\-:!\.] - це набір (множина) символів, який включає різні пунктуаційні знаки. Ми проходимося по рядку та прибираємо їх, оскільки заміна відбувається на порожній рядок.



Python  потужна універсальна мова



Розглянемо, ще один корисний приклад - форматування телефонних номерів. Нам необхідно змінити формат телефонних номерів. В тексті в нас телефони записані в такому форматі 050-171-1634, нам необхідно замінити їх на формат (050) 171-1634



✂️ Цей код можна запустити!

import re

phone = """
        Михайло Куліш: 050-171-1634
        Вікторія Кущ: 063-134-1729
        Оксана Гавриленко: 068-234-5612
        """
pattern = r"(\d{3})-(\d{3})-(\d{4})"
replacement = r"(\1) \2-\3"
formatted_phone = re.sub(pattern, replacement, phone)

print(formatted_phone)



У цьому прикладі регулярний вираз (\d{3})-(\d{3})-(\d{4}) шукає телефонні номери в форматі XXX-XXX-XXXX. Кожна група чисел (\d{3} або \d{4}) поміщена в круглі дужки для збереження в групах. У рядку replacement, ми звертаємося до цих знайдених груп \1, \2, \3 і вони відповідають першій, другій та третій групі відповідно. Ми кажемо, що першу групу наприклад треба помістити в круглі дужки. Далі пробіл та між групами залишити дефіс.



Отримаємо наступне виведення:



Михайло Куліш: (050) 171-1634
Вікторія Кущ: (063) 134-1729
Оксана Гавриленко: (068) 234-5612



Ось так легко, за допомогою регулярних виразів, ми виконали складну операцію форматування телефонних номерів в тексті.



Метод re.sub є важливим інструментом у роботі з рядками, коли потрібно модифікувати текст за допомогою регулярних виразів. Це дозволяє не тільки замінювати текст, але й проводити складні перетворення, використовуючи групи та посилання на них. Але це вимагатиме від вас зусиль, щоб глибоко зрозуміти регулярні вирази, та практики, щоб навчитися повноцінно застосовувати ці знання.





Метод split



Функція re.split() в модулі re Python використовується для розбивання рядка за заданим регулярним виразом. Це дозволяє розділяти текст на частини за складнішими критеріями, ніж простий рядковий метод split().



Синтаксис:



import re

list_of_elements = re.split(pattern, string)



pattern - регулярний вираз, який використовується як роздільник.
string - рядок, який потрібно розділити.


Метод повертає список рядків, розділених за заданим регулярним виразом.



Почнемо з простого, та розділимо рядок на слова, використовуючи пробіли як роздільники.



✂️ Цей код можна запустити!

import re

text = "Python - це проста, але потужна мова програмування."
pattern = r"\s+"
words = re.split(pattern, text)

print(words)  # Виведе список слів у рядку



У цьому прикладі \s+ відповідає одному або більше пробільним символам (пробіл, табуляція тощо). І виведення буде як у звичайного метода split():



['Python', '-', 'це', 'проста,', 'але', 'потужна', 'мова', 'програмування.']



Спробуємо розділити рядок на частини, використовуючи пунктуаційні знаки як роздільники.



✂️ Цей код можна запустити!

import re

text = "Python - потужна; проста, універсальна: мова!"
pattern = r"[;,\-:!\s]+"
elements = re.split(pattern, text)

print(elements)  # Виведе список частин, розділених пунктуацією



Тут регулярний вираз [;,\-:!\s]+ збігається з будь-якою послідовністю одного або більше символів з набору ;, ,, -, :, ! або будь-якого пробільного символу. Завдяки квантифікатору +, послідовність роздільників розглядається як один роздільник, що допомагає уникнути створення пустих рядків у результаті виведення.



['Python', 'потужна', 'проста', 'універсальна', 'мова', '']



Останній пустий елемент, кінець рядка, можна видалити зрізами elements[:-1:], якщо є бажання. Чому він виник? Коли ви використовуєте re.split() для розділення рядка, функція шукає входження шаблону (роздільника) і розбиває рядок кожного разу, коли знаходить цей шаблон. Якщо шаблон присутній на кінці рядка, а в нас в кінці рядка знак оклику !, re.split() розділить рядок після цього шаблону, що призводить до створення додаткового пустого рядка.



Виконаємо, ще один розділ рядка за шаблоном, що містить кілька можливих роздільників. Зауважимо, що звичайний метод split() таке вже зробити не зможе.



✂️ Цей код можна запустити!

import re

text = "apple#banana!mango@orange;kiwi"
pattern = r"[#@;!]"
fruits = re.split(pattern, text)

print(fruits)



У цьому прикладі [#@;!] створює набір символів, який включає #, @, ;, і !, кожен з яких може бути використаний як роздільник. І ми отримуємо список з фруктами:



['apple', 'banana', 'mango', 'orange', 'kiwi']



Застосування re.split є дуже корисним для розділення рядків, коли вам потрібно використовувати більш складні критерії, ніж просте розділення за фіксованим символом. Та особливо корисно в задачах обробки тексту, де потрібно розділити рядки за різними символами або шаблонами.

Ключові аспекти: основні функції модуля re



Регулярні вирази в Python - потужний інструмент для пошуку, заміни та маніпуляції текстовою інформацією. Вони дозволяють виконувати складні операції над рядками за допомогою досить лаконічного синтаксису. Основні функції модуля re, які ми розглянули:



re.search(pattern, string) - використовується для пошуку першого входження шаблону в рядку. Повертає об'єкт Match, якщо відповідність знайдена.
re.findall(pattern, string) - знаходить всі входження шаблону в рядку. Повертає список всіх знайдених відповідностей.
re.sub(pattern, repl, string) - замінює всі входження шаблону в рядку на інший рядок. Використовується для модифікації та форматування тексту.
re.split(pattern, string) - розбиває рядок за заданим шаблоном. Повертає список рядків, отриманих після розділення.


Використання регулярних виразів вимагає розуміння їхнього синтаксису та особливостей. Спеціальні символи, такі як *, +, ?, квадратні та круглі дужки, мають конкретні функції у регулярних виразах. Розуміння цих елементів дозволяє виконувати складні операції пошуку та редагування з текстом.

Коректне застосування регулярних виразів може значно спростити обробку тексту, автоматизацію задач та вирішення складних проблем обробки даних.
'''



































######### Лекція 4. чт 06.03.2025. Тема 4. Регулярні вирази та розширена робота з рядками (лектор Сергій Коденко)

s1 = 'Hello World'
s2 = 'Hello Python'
text1 = '''Helloo world 
        and Python'''       # виводить як 2 різні рядки

'''
Коментар
Багаторядковий
Хоч він і не зовсім коментар
'''

# text2 = 'very long tex is here'\ 
#         'to show how it works'    # виводить як 1 рядок

# print(s1,s2,text1,text2, sep="\n")


# a = 3
# a = a +\
# 3

# text2 = 'very long tex is here \n to show how it works'  
# print(text2)

# text3 = '\t1\t2\t20\t100\n100\t20\t1\t2'
# print(text3, sep='\n')


# text2 = 'very long tex is here \r to show how it works'  
# print(text2, sep='\n')

# import time
# for i in range(100):
#     print(f"\r{i}% Ready", end='')  # \r повертає на початок рядка
#     time.sleep(.1)
# print(text2, sep='\n')


# print("very long text", end='') # end='' не переносить на новий рядок
# print("\rshort text")


# text4 = 'text pt 1\vtext pt 2'   # вертикальна табуляція на Windows не працює
# print(text4)

# text4 = 'text pt 1 \f\f\f text pt 2'   # вертикальна табуляція на Windows не працює
# print(text4)

# text4 = 'text pt 1 \n\t text pt 2'   # майже аналог вертикальної табуляція на Windows
# print(text4)

# text4 = 'text pt 1 \b\b\b text pt 2'   # backspace
# print(text4)


# print('\'')       # \ екранує знак ' лапок
# print('\'    \\')
# print('\'    \\   \077')
# print('\'    \\   \xc3')


### функції рядків

s = 'Hello shiny wolrd!'
# print(s.find("l"))
# print(s.find("o"))
# print(s.find("shiny"))
# print(s.find("x"))

# print(s.rfind("l"))   # right find з кінця шукає й нумерація з кінця символів йде
# print(s.count("l"))

#                       # знайти 2-гу 'l'

# start = s.find('l')+1          # шукаємо 1-шу "l" + 1 позиція
# print(s.find('l', start))      # 2-гу "l" починаючи з +1 позиції від 1-ї "l"



# s = 'Hello shiny wolrd!'

# print(s.index('l'))

# # print(s.index('x')) # видає Value Error, якшр такого символа немає в рядку
# print(s.find("x")) # повертає не помилку, а -1


# try:
#     print(s.index('l'))
# except Exception as e:
#     print(e)


# try:
#     print(s.rindex('l', 5))  # починаємо шукати з 5-го символу
# except Exception as e:
#     print(e)


# try:
#     print(s.rindex('с', 5))
# except Exception as e:
#     print("Not Found")



#### метод split()

# s = 'Hello shiny wolrd!'

# print(s.split(' '))

# print(s.split('l'))


# input = 'Snitch John j.snitch@gmail.com +123456789'
# print(input.split("it"))

# l1 = input.split()

# csv_line = ','.join(l1)   # comma-separated value
# print(csv_line)




##### вставити код по csv  input2  !!!!!

# !!!!




# s = '   some nice text   '
# l1 = ['John    ', ' Smith  ', '    coolmail@mail.com', '+657677766  ']
# l2 = []
# print('|', end='')
# print(s.strip(), end='')  # прибирає зайві пробіли на початку та в кінці
# print('|')
# for el in l1:
#     l2.append(el.strip())
# print(l2)

# for el in l1:
#     l2.append(el.rstrip())
# print(l2)




# s = '   some nice text   '.strip()
# print(s)

# print(s.replace('nice', 'cool'))



# s = '   some nice text nice nice  '.strip()
# # print(s)

# print(s.replace('nice', 'cool'))



# s = '   some nice text nice nice  '.strip()
# print(s)

# s = s.replace('nice', 'cool', 1)   # бо рядкі незмінні, тому треба створювати нову змінну
# print(s.replace('nice', 'cool', 1)) # заміна тільки 1-шого 'nice' на 'cool'


# print(s.replace(' ', ''))


# s3 = 'cool'.join(s.split('nice'))
# print(s3)



##### видалення суфіксів (постфікси) і префіксів


# s = 'some nice text'
# s1 = 'cool nice text'
# s2 = 'some nice texts'
# print(s.removeprefix('some'))    # прибрати слово some на початку, якщо рядок починається з цього префікса
# print(s1.removeprefix('some'))
# print(s2.removeprefix('some'))

# print(s.removesuffix('text'))    # прибрати слово some на початку, якщо рядок починається з цього префікса
# print(s1.removesuffix('text'))
# print(s2.removesuffix('text'))


# l = ['1', '2', 'n=2', 'n=3']
# for el in l:
#     print(el.removeprefix('n='))

# orig = 'somenictxl'
# trans= 'соменіцтхл'
# s = 'some nice text'
# s1 = 'cool nice text'
# s2 = 'some nice texts'

# trans_tab = str.maketrans(orig, trans)  # табличка транслітерації англ букв в укр букви
# print(s.translate(trans_tab))  # виведення проведеної транслітерації на основі табличка транслітерації.




##### форматування рядків  f-string

# for i in range(8):
#      print(f'int: {i:d}; hex{i:#x}; '\
#      f'oct:{i:#o}; bin:{i:#b}; float:{i:f}')



# for i in range(8):
#      print(f'int: {i:d}; hex{i:#4x}; '\
#      f'oct:{i:#5o}; bin:{i:#7b}; float:{i:4.1f}')


# for i in range(8):
#      print(f'int: {i:d}; hex{i:#4x}; '\
#      f'oct:{i:#5o}; bin:{i:<7b}; float:{i:4.1f}')


# for i in range(8):
#      print(f'int: {i:d}; hex{i:#4x}; '\
#      f'oct:{i:#5o}; bin:{i:^#7b}; float:{i:4.1f}')



# ###### Регулярні вирази (Regular expressions) re - regex, regexp
# # описуємо рядки за допомогою умонвих позначок

# import re 

# # re.findall()

# s = '1234 asd1234 1234 sadas 1231 123 123 asd'
# pat1 = r'[0-9]{1,}'  # r'[0-9 a-z]'   r'[01234456789]'   {1,} від 1 і більше разів має зустрічатися число
#                      # raw string
# res1= re.findall(pat1, s)    # знайти всі входження - дуже часто використовується
# print(res1)

# s = '1234 asd1234 1234 sadas 1231 123 123 asd'
# pat1 = r'[0-9]{1,3}'  # r'[0-9 a-z]'   r'[01234456789]'   {1,3} від 1 і до 3 разів має зустрічатися число - розбивається на шматочки по 3 символи
#                      # raw string
# res1= re.findall(pat1, s)    # знайти всі входження - дуже часто використовується
# print(res1)


# s = '1234 asd1234 1234 sadas 1231 123 123 asd'
# pat1 = r'[a-zA-Z]{1,3}'  # r'[0-9 a-z]'   r'[01234456789]'   {1,3} від 1 і до 3 разів має зустрічатися число
#                      # raw string
# res1= re.findall(pat1, s)    # знайти всі входження - дуже часто використовується
# print(res1)

# # d - digit
# # +  1 і більше


# s = '1234 asd1234 1234 sadas 1231 123 123 asd'
# pat1 = r'\d{1,3}'  # r'[0-9 a-z]'   r'[01234456789]'   {1,3} від 1 і до 3 разів має зустрічатися число - розбивається на шматочки по 3 символи
#                      # raw string
# res1= re.findall(pat1, s)    # знайти всі входження - дуже часто використовується
# print(res1)

# s = '1234+asd1234 +1234 sadas+ 1231 123+ 123 asd'
# pat1 = r'\d+'  # r'[0-9 a-z]'   r'[01234456789]'   {1,3} від 1 і до 3 разів має зустрічатися число - розбивається на шматочки по 3 символи
#                      # raw string
# res1= re.findall(pat1, s)    # знайти всі входження - дуже часто використовується
# print(res1)


# s = '1234+asd1234 +1234 sadas+ 1231 123+ 123 asd'
# pat1 = r'\d+'  # r'[0-9 a-z]'   r'[01234456789]'   {1,3} від 1 і до 3 разів має зустрічатися число - розбивається на шматочки по 3 символи
#                      # raw string
# res1= re.findall(pat1, s)    # знайти всі входження - дуже часто використовується
# print(res1)

# s = '1234+asd1234 +1234 sadas+ 1231 123+ 123 asd'
# pat1 = r'\++'  # r'[0-9 a-z]'   r'[01234456789]'   {1,3} від 1 і до 3 разів має зустрічатися число - розбивається на шматочки по 3 символи
#                      # raw string
# res1= re.findall(pat1, s)    # знайти всі входження - дуже часто використовується
# print(res1)




# # re.search()   # видає єдине входження яке відповідає патерну, індекси
# s = '1234+asd1234 +1234 sadas+ 1231 123+ 123 asd'
# pat1 = r'\++'  # r'[0-9 a-z]'   r'[01234456789]'   {1,3} від 1 і до 3 разів має зустрічатися число - розбивається на шматочки по 3 символи
#                      # raw string
# res1= re.findall(pat1, s)    # знайти всі входження - дуже часто використовується
# print(res1)
# res2=re.search(pat1, s)
# print(res2)




import re

# s2 = 'pi is 3.14 and it\'s a constant'   # \' апостроф, не лапки
# pat2 = r'\d\.\d+'
# print(re.findall(pat2, s2))

# import re

# s2 = 'pi is 3.14 and it\'s a constant, .5 is also a constant but has no name'
# pat2 = r'\d*\.\d+'
# print(re.findall(pat2, s2))


# mail = 'jsmith@mai.com'  # перевірка і-мейлів що є а що не є імейлом
# pat3 = r'w+@\w+\.\w'
# print(re.match(pat3, mail))   # перевіряючи рядок від початку співпадає з палітрою
# print(re.match(pat3, mail).group()) 




# ##### взяти з кода від лектора !!!!!!!
# re.findall()
# pat3 = r'^[w+@\w+\.\w]'   # ^ початок рядка






# # pat3=r'[\w\._]+@\w+\.\w+'
# прикласти cheat sheet
import re #regular expressions regex regexp

# s='1234+78998 7+++asd1234  ++ ++ 1234sdas 1231 123 123asdasd'
# pat1=r'\w+'
# # d - digit
# # + - 1 і більше
# res1=re.findall(pat1,s)
# res2=re.search(pat1,s)
# print(res1)
# print(res2.group())
# print(res2.span())
# s2='pi is 3.14 and it\'s a constant'\
#     ', .5 is also a constant but has no name'

# pat2=r'\d*\.\d+'
# print(re.findall(pat2,s2))

# mail="j.s_m_ith@stud.mail.com '; drop database; coll_11@10mituesmail.com
