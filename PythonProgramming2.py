
####
#### Тема 2. Керуючі конструкції, винятки
####

   ### Умовні оператори, цикли

'''
За замовчуванням у Python інструкції виконуються одна за одною зверху вниз. Послідовність виконання виразів у програмі називається «потік виконання» (Flow of execution).

У Python існує три способи управління потоком виконання:

умовне виконання — виконання блоку інструкцій тільки за деякої умови;
цикли — повторення виконання блоку інструкцій, доки виконується деяка умова;
винятки — механізм обробки помилок, що дозволяє керувати потоком програми при виникненні виняткових ситуацій (наприклад, помилок або інших непередбачених обставин).

У Python умовне виконання, цикли та винятки формують основу управління потоком виконання програми, дозволяючи розробляти складні та гнучкі алгоритми обробки даних і взаємодії з користувачем.

Умовний оператор в Python - це конструкція мови, яка дозволяє виконувати певні дії в залежності від того, чи виконується певна умова.
Умовний оператор у Python має такий синтаксис:

if <умова>:
    <тіло if-блоку>
else:
    <тіло else-блоку>
   
if <умова>: вираз, який повертає True або False
<тіло if-блоку> це набір інструкцій, які виконуються, якщо умова є True
<тіло else-блоку> це набір інструкцій, які виконуються, якщо умова є False. Блок else є необов'язковим і може бути опущеним.

На малюнку нижче ми бачимо, що виконання коду відрізняється, якщо значення змінної num є більшим, або меншим за 10.

   '''
num = 15  # приклад значення для num

if num > 10:
    print("num більше за 10")
else:
    print("num не більше за 10")

'''
Спочатку ми задаємо значення змінної num. Це може бути будь-яке значення для перевірки різних умов. Потім використовуємо умовний оператор if для перевірки, чи num більше за 10. Якщо умова num > 10 вірна, виконується код усередині блоку if і на екран виводиться повідомлення "num більше за 10".
Якщо умова не вірна, виконується код усередині блоку else, і на екран виводиться повідомлення "num не більше за 10".

Наприклад, розглянемо наступний код, який визначає, що число x є парним:
'''

# x = int(input('Введіть число: '))

# if x % 2 == 0:
#     print("Число x є парним.")
# else:
#     print("Число x є непарним.")

'''
У цьому коді <умова> є x % 2 == 0. Якщо ця умова є істинною, тобто число x є парним, виводиться повідомлення "Число x є парним.". Якщо умова є хибною, тобто число x є непарним), виводиться повідомлення "Число x є непарним.".

Що робити, якщо в нас є низка умов? Для цього у Python реалізований оператор контролю виконання if ... elif ... else. Оператор контролю виконання дозволяє виконувати блоки інструкцій не завжди, а тільки тоді, коли буде виконана умова.
'''

# Синтаксис умовного оператора:

'''
починається з ключового слова if, за яким йде умова;
після умови ставиться двокрапка і з нового рядка з відступом йде блок інструкцій, які будуть виконані, якщо умова виконується;
після блоку if може бути нуль або більше блоків elif, інтерпретатор послідовно перевірятиме усі умови elif зверху вниз, доки не знайде той, який виконується;
потім може бути один блок else, який виконується, якщо всі попередні умови не виконуються.
'''

# a = input('Введіть число')
# a = int(a)
# if a > 0:
#     print('Число додатне')
# elif a < 0:
#     print("Число від'ємне")
# else:
#     print('Це число - нуль')

'''
Під час виконання умовного оператора інтерпретатор Python перевіряє умови зверху вниз, доки не знайде те, яке виконується, потім виконає вираз для цієї умови та вийде з перевірки умов.
Але будьте уважні, бо досить легко в такому операторі зробити помилку. Подивіться на цей код нижче та визначте, що з ним не так?
'''
# a = input('Введіть число')
# a = int(a)

# if a > 0:
#     print('Число додатне')
# elif a == 1:
#     print('Число дорівнює 1')
# else:
#     print("a <= 0")

'''
Подивились? Основна проблема цього коду полягає в тому, що перевірка elif a == 1: є надмірною та ніколи не виконується, оскільки умова if a > 0: вже включає в себе випадок, коли a дорівнює 1. Якщо a дорівнює 1, то програма виведе 'Число додатне', а не 'Число дорівнює 1', як це могло б здатися. Отже цей рядок коду ніколи не буде виконаний, оскільки будь-яке число, рівне 1, вже задовольнить попередню умову a > 0. Це досить поширена помилка новачків програмування у розумінні логіки умовних операторів.
Виправлений варіант цього коду міг би виглядати так:
'''
# a = input('Введіть число')
# a = int(a)

# if a == 1:
#     print('Число дорівнює 1')
# elif a > 0:
#     print('Число додатне')
# else:
#     print("a <= 0")

""" 
У цьому випадку перевірка на рівність 1 виконується першою, тому логіка коду стала правильною. """

   ### Логічні вирази


""" Умовний оператор if ... elif ... else у Python у якості умов може приймати змінні типу bool або будь-який вираз, який він виконає і результат перетворить в bool. Коли в якості умови в умовний оператор ми передаємо вираз, то вираз виконається, а результат його виконання буде перетворений в тип bool.
Для зручності у Python є механізм неявного приведення будь-якого типу до типу bool. 
"""
   
 # Правила приведення до bool достатньо інтуїтивні.

  #Правило перше - число 0 приводиться до False (ціле, дійсне або комплексне). 
# Це правило перетворення дуже важливе, оскільки дозволяє використовувати числові змінні 
# безпосередньо в умовних виразах. Наприклад, у коді нижче ми пишемо if money: 
# і якщо money дорівнює 0, умова вважається неправдивою, 
# і виконується код у блоку else.
 

money = 0
if money:            # теж саме що 'if money == 0:'
    print(f"You have {money} on your bank account")
else:
    print("You have no money and no debts")


money = 10 
if money:             # теж саме що 'if money == 10:'   
    print(f"You have {money} on your bank account")
else:
    print("You have no money and no debts")

   # Правило друге - значення None приводиться до False. 
# У коді нижче, якщо змінна result має значення None, умова if result: 
# оцінюється як False, тому що None завжди вважається неправдивим (False) у булевому контексті. 
# Таким чином в нас result є None, а значить виконується код у блоку else, 
# і на екран виводиться повідомлення "Result is None, do something".

result = None
if result:
    print(result)
else:
    print("Result is None, do something")

  # Правило третє - порожній контейнер, порожній рядок тощо, приводиться до False. Розглянемо для прикладу просту взаємодію з користувачем та умовного виконання.



# user_name = input("Enter your name: ")

# if user_name:
#     print(f"Hello {user_name}")
# else:
#     print("Hi Anonym!")


""" Спочатку ми просимо користувача ввести своє ім'я за допомогою функції input(), і результат цього вводу зберігається у змінній user_name.
 """
# user_name = input("Enter your name: ")


""" Потім відбувається перевірка умови за допомогою оператора if. Умова перевіряє, чи змінна user_name не є порожньою. Якщо користувач ввів ім'я (тобто user_name містить непорожній рядок), умова оцінюється як True, і виконується блок коду після if.
 """

# print(f"Hello {user_name}")

""" У цьому випадку на екран виводиться привітання з введеним ім'ям. Якщо користувач просто натиснув Enter, не вводячи ім'я, а отже змінна user_name є порожнім рядком, умова оцінюється як False, і виконується блок коду після else. У цьому випадку на екран виводиться привітання "Hi Anonym!".
 """


# Правило останнє - все інше приводиться до True
""" 
Ці правила приведення до bool дозволяють писати умовні вирази у Python практично літературною англійською. В будь-якому разі, такий код стає дуже зрозумілим. """


   ## Оператор is

""" Оператор is у Python використовується для перевірки того, чи два об'єкти вказують на одну і ту ж область пам'яті, тобто чи вони є одним і тим же об'єктом.
Цей оператор відрізняється від оператора ==, який перевіряє рівність значень об'єктів.
Оператор is у Python використовується для перевірки ідентичності об'єктів, тобто для встановлення, чи дві змінні вказують на один і той самий об'єкт в пам'яті. Цей оператор, який часто називають оператором ідентичності, має особливе значення при роботі з незмінними типами даних, такими як числа та рядки. У випадку з незмінними типами даних Python може кешувати об'єкти, що іноді призводить до того, що оператор is повертає True для об'єктів з однаковими значеннями, як у випадку з дуже малими цілими числами або короткими рядками. Корисно мати цю інформацію для випадку, якщо ви зіткнетеся з таким винятком у своєму коді.
 """
a = [1, 2, 3]
b = a
c = [1, 2, 3]

print(a is b)  # True
print(a is c)  # False

""" У цьому прикладі, b є тим самим об'єктом, що й a, тому що вони вказують на один і той же список. Натомість c створює новий список, який містить ті самі значення, але фізично є окремим об'єктом.
 """

""" Однак основне його застосування - це перевірка, чи змінна є None.
 """
# if my_var is None:
    # Робимо щось, якщо 'my_var' є 'None'

""" Таке використання is є оптимальним, оскільки існує лише один об'єкт None у Python.

Отже оператор is повинен використовуватися для перевірки ідентичності об'єктів, коли важливо, щоб дві змінні вказували на один і той же об'єкт. А оператор == повинен використовуватися для перевірки рівності значень двох об'єктів. """


  ## Булева алгебра
""" 
Що робити, якщо у нас складна умова, яка поєднує в собі декілька вкладених умов? Наприклад, щоб користувач міг орендувати автомобіль, потрібно, щоб у користувача обов'язково було вказане ім'я, користувач був старший 18 і були водійські права.
В коді це виглядає наступним чином.
"""  """
""" 
# name = "Taras"
# age = 22
# has_driver_licence = True

# if name and age >= 18 and has_driver_licence:
#     print(f"User {name} can rent a car")

"""
Ми бачимо, що тут з'явилися нова операція з and. В Python для побудови логічних умов з декількох, використовується булева алгебра.
Булева алгебра — це галузь математики, яка займається вивченням істинності виразів та їх обробкою. Вона названа на честь Джорджа Буля, англійського математика, який зробив значний внесок у цю область. Булева алгебра стала фундаментом для розвитку цифрової логіки та комп'ютерних наук.
У найпростішій формі булева алгебра оперує з двома значеннями: True (істина) і False (неправда). Тому у програмуванні застосовують бінарну логіку, де можливі значення також можуть бути True та False.

Булева алгебра будується на трьох основних операціях: "і", "або", "ні".
☝ Існують ще допоміжні операції, але ми розглянемо основні.

Основні операції в булевій алгебрі включають:

AND (і): Операція повертає True, якщо обидва операнди є True. Наприклад, True AND True є True, в той час як True AND False є False.
OR (або): Операція повертає True, якщо хоча б один з операндів є True. Наприклад, True OR False є True.
NOT (ні): Унарна операція, яка інвертує значення; True стає False, а False стає True.


Комбінація булевих значень і операцій формує складніші умови. Наприклад, вираз (True AND False) OR (True AND NOT False) використовує декілька булевих операцій.

У Python оператори булевої алгебри — це оператори not, and, or. Булева алгебра є ключовою для умовних операторів та логічних умов в програмуванні. Вона дозволяє контролювати потік виконання програми (наприклад, за допомогою if-else умов в Python) та виконувати складні логічні перевірки.
Наприклад, нам треба визначити, чи введене користувачем число є парним двозначним числом:
'''
""" 
# num = int(input("Введіть число: "))
# length = len(str(num))

# if length == 2 and num % 2 == 0:
#     print("Парне двозначне число")
# else:
#     print("Ні")

"""
'''
Змінна length = len(str(num)) перетворює число в рядок str(num) і обчислює його довжину за допомогою функції len(). Ця довжина використовується для перевірки, чи число є двозначним.
Далі умова if length == 2 and num % 2 == 0: перевіряє дві речі. Чи довжина числа length дорівнює 2 та чи число num є парним. Якщо обидві умови вірні, виводиться повідомлення "Парне двозначне число". Якщо умова в if не виконується, тобто число не є парним двозначним, виконується код після else, і виводиться повідомлення "Ні".

У булевій алгебрі також важливі поняття булевої функції та булевих таблиць істинності, які використовуються для опису та аналізу логічних операцій. Булеві оператори в Python, такі як and, or, і not, є основними інструментами для побудови складних логічних умов. Вони використовуються для оцінки істинності або неправдивості виразів та є ключовими у процесі прийняття рішень у програмах.
"""

   ## Оператор and (і)

""" Оператор and використовується для перевірки, чи обидві умови є істинними. Вираз з and вважається True тільки тоді, коли обидва операнди істинні.

Наприклад:
a = True and False  # False

Таблиця істинності для and:
 """
# A       B       A and B
# True   True      False
# True   False     False
# False  True      False
# False  False     False

""" Ця таблиця показує, що вираз A and B буде істинним тільки тоді, коли обидва операнди A і B істинні.
 """
   
   
   ## Оператор or (або)

""" Оператор or перевіряє, чи хоча б одна з умов є істинною. Вираз із or вважається True, якщо принаймні один із операндів є істинним:
 """
a = True or False  # True
""" 
Таблиця істинності для or:
 """
# A       B       A and B
# True   True      True
# True   False     True
# False  True      True
# False  False     False

""" З таблиці видно, що вираз A or B є істинним у всіх випадках, крім випадку, коли обидва операнди є неправдивими.
 """

   ## Оператор not (ні)

""" Оператор not використовується для інвертування істинності операнду. Якщо операнд істинний, not перетворює його на неправдивий, і навпаки:
 """
a = not 2 < 0  # True

""" У цьому прикладі, оскільки 2 < 0 є неправдивим (False), оператор not перетворює його на True.
Таблиця істинності для not:
 """

# A      not A
# True   False
# False  True


""" На останок розглянемо завдання "FizzBuzz”. Завдання часто зустрічається на співбесідах з програмування. Його суть полягає в написанні програми, яка для заданого числа:

Виводить "Fizz", якщо число кратне якомусь певному числу (наприклад, 3);
Виводить "Buzz", якщо число кратне іншому певному числу (наприклад, 5);
Виводить "FizzBuzz", якщо число кратне обом цим числам;
В іншому випадку виводить саме число.

На перший погляд це досить проста задача, але навіть досвідчені програмісти можуть тут помилитися. Задача "FizzBuzz" часто вважається базовим тестом на здатність кандидата розуміти та застосовувати основні концепції програмування. Хоча вона може здатися простою, її ефективне вирішення вимагає злагодженого застосування декількох основних програмувальних принципів.
 """

# Задаємо конкретне число
# num = int(input('Введіть число: '))

# # Перевіряємо кратність
# if num % 3 == 0 and num % 5 == 0:
#     print("FizzBuzz")
# elif num % 3 == 0:
#     print("Fizz")
# elif num % 5 == 0:
#     print("Buzz")
# else:
#     print(num)

""" Умова if num % 3 == 0 and num % 5 == 0 перевіряє, чи введене число кратне і 3, і 5 одночасно. Ця перевірка стоїть першою, оскільки вона є найспецифічнішою.
Якщо ця умова виконується, виводиться "FizzBuzz". Якби ця перевірка була після інших, вона б ніколи не виконувалася, тому що більш загальні умови (кратність 3 або 5) вже б були виконані. Далі elif num % 3 == 0 перевіряє, чи число кратне тільки 3. Ця умова виконується тільки якщо попередня умова (кратність і 3, і 5) не виконалася. Якщо це правда, виводиться "Fizz". Умова elif num % 5 == 0 перевіряє, чи число кратне тільки 5. Як і попередня, ця умова виконується лише тоді, коли попередні перевірки не виявилися істинними. У випадку виконання цієї умови виводиться "Buzz". Якщо жодна з вищезазначених умов не виконалася, то else гарантує, що буде виведене саме число.
Порядок цих умов є ключовим, бо він забезпечує, що найспецифічніша перевірка - кратність і 3, і 5 має пріоритет, а потім перевіряються менш специфічні випадки - кратність окремо 3 або 5. Це запобігає випадкам, коли числа, які кратні і 3, і 5, були б неправильно оброблені через виконання менш специфічних умов.
 """

    ## Блоки інструкцій та тернарні оператори
""" 
У Python особливий синтаксис стосовно виділення блоків інструкцій. Щоб інтерпретатор сприйняв набір інструкцій як окремий блок, достатньо виділити всі інструкції цього блоку однаковою кількістю відступів зліва. У Python рекомендується для виділення одного рівня вкладеності для блоку інструкцій використовувати 4 пробіли. """

# x = int(input("X: "))
# y = int(input("Y: "))

# if x == 0:
#     print("X can`t be equal to zero")
#     x = int(input("X: "))

# result = y / x
# print(result)
""" 
Ви можете використати символи табуляції для виділення блоку інструкцій, це не помилка, але такий спосіб не рекомендується.
Синтаксичною помилкою буде змішати в одному файлі виділення блоків за допомогою табуляцій та пробілів одночасно, пам'ятайте про це.

Також можна виділяти декілька рівнів вкладеності, додаючи ще 4 пробіли зліва для всіх інструкцій блоку: """

# x = int(input("X: "))
# y = int(input("Y: "))

# if x == 0:
#     print("X can`t be equal to zero")
#     x = int(input("X: "))

#     if x == 0:
#         print("X can`t be equal to zero")
#         x = int(input("X: "))

#         if x == 0:
#             print("X can`t be equal to zero")
#             x = int(input("X: "))

# result = y / x
# print(result)

""" 
В цьому прикладі тричі повторюється перевірка на нерівність x нулю, і на кожну перевірку блок інструкцій виділяється додатковими 4-ма пробілами. Сенсу в додаткових перевірках немає, це зроблено тільки заради демонстрації.

Наведемо наступний приклад вкладеності для визначення чвертей для координатної площини, щоб закріпити розуміння блоку інструкцій. Даний фрагмент коду реалізує визначення квадранту точки з координатами x та y на координатній площині. """

# if x >= 0:
#     if y >= 0:  # x > 0, y > 0
#         print("Перша чверть")
#     else:  # x > 0, y < 0
#         print("Четверта чверть")
# else:
#     if y >= 0:  # x < 0, y > 0
#         print("Друга чверть")
#     else:  # x < 0, y < 0
#         print("Третя чверть")

""" Умовні оператори вкладені один в одного, що означає, що перевірка умов відбувається поетапно, і якщо перша умова x >= 0 виконується, то програма переходить до внутрішнього блоку і перевіряє умову y >= 0. Якщо ця умова також виконується, то точка знаходиться в першій чверті. Якщо умова y >= 0 не виконується, то точка знаходиться в четвертій чверті.
Якщо умова x >= 0 не виконується, то програма переходить до наступного внутрішнього блоку, але вже для оператора else, де виконується перевірка умови y >= 0. Якщо ця умова виконується, то точка знаходиться в другій чверті, якщо ні - у третій чверті.
Отже, в результаті виконання даного коду буде виведена назва чверті, в якій знаходиться точка з координатами (x, y).
 """


    # Тернарні операції

""" Тернарні оператори в Python є елегантним способом вираження умовних виразів у скороченій формі. Вони дозволяють вам вибирати між двома значеннями залежно від того, чи є певна умова істинною або неправдивою. Це робить код компактнішим і часто полегшує його читання.

У прикладі нижче, вираз state = "nice" if is_nice else "not nice" використовує тернарний оператор для присвоєння рядка "nice" змінній state, якщо is_nice є істинним True, і рядка "not nice", якщо is_nice є неправдивим False:
 """

# трохи по-калічному (зазвичай 'умова - результат', а тут 'результат - умова') 
# пишеться умова і результат. Спочатку що треба вивести в результат, а потім за якої умови

is_nice = True
state = "nice" if is_nice else "not nice" # виведи значення "nice", якщо змінна `is_nice` дорівнює True  
print(state)                              # виведи значення "not nice", якщо змінна `is_nice` дорівнює False
 
is_nice = False
state = "nice" if is_nice else "not nice" # виведи значення "nice", якщо змінна `is_nice` дорівнює True  
print(state)                              # виведи значення "not nice", якщо змінна `is_nice` дорівнює False
 
""" 
У цьому прикладі значенням змінної state буде рядок 'nice'.
Такий підхід дозволяє швидко перевірити умову, а не писати декілька рядків оператора if ... else .... Для порівняння, ось як виглядав би той самий вираз без використання тернарного оператора, а з використанням стандартного блоку if-else: 
"""
is_nice = True
if is_nice:
    state = "nice"
else:
    state = "not nice"

print (state)

is_nice = False
if is_nice:
    state = "nice"
else:
    state = "not nice"

print (state)

""" Ця версія коду робить те саме, що й тернарний оператор, але займає більше місця і є менш компактною.

Ще одним корисним варіантом тернарного оператора в Python є використання оператора or для швидкого визначення значення. """

some_data = None
msg = some_data or "Не було повернено даних"
print(msg)

some_data = 1000
msg = some_data or "Не було повернено даних"
print(msg)

""" 
В прикладі ми присвоїмо msg значення some_data, якщо some_data не є None (або іншим значенням, яке вважається неправдивим у Python, як False, порожній рядок, порожній список тощо). У випадку, якщо some_data є None або неправдивим, msg отримає значення "Не було повернено даних". В нашому випадку msg буде містити рядок 'Не було повернено даних', це зручно, коли потрібно швидко перевірити значення та показати повідомлення, якщо значення some_data є None.

Без використання скороченої форми тернарного оператора з or, вираз msg = some_data or "Не було повернено даних" може бути переписаний з використанням стандартного умовного оператора if ... else ... наступним чином:
 """

some_data = None
if some_data:
    msg = some_data
else:
    msg = "Не було повернено даних"

some_data = 1000
if some_data:
    msg = some_data
else:
    msg = "Не було повернено даних"

""" 
Цей варіант коду, хоч і більш довгий і менш компактний, може бути більш зрозумілим для новачків або у випадках, коли потрібна більш чітка логіка умови.
☝ Зверніть увагу, що для скороченої форми використовується саме оператор or (АБО).
"""

   ## Оператор match

""" Оператор match, введений у Python починаючи з версії 3.10, є схожим на оператори switch-case в інших мовах програмування. Він дозволяє порівнювати значення з декількома шаблонами і виконувати різні блоки коду в залежності від того, який шаблон відповідає значенню.

# Структура оператора match
  
match змінна:
    case шаблон1:
        # виконати код для шаблону 1
    case шаблон2:
        # виконати код для шаблону 2
    case _:
        # виконати код, якщо не знайдено відповідностей

Оператор match - це свого роду розширена і більш гнучка версія оператора if-elif-else. Він дозволяє порівнювати значення з рядом шаблонів і, залежно від відповідності, виконувати певні дії.
"""

fruit = "apple"

match fruit:
    case "apple":
        print("This is an apple.")
    case "banana":
        print("This is a banana.")
    case "orange":
        print("This is an orange.")
    case _:
        print("Unknown fruit.")

""" У прикладі fruit - це змінна, значення якої ми хочемо перевірити:

#fruit = "apple"

Далі оператор match порівнює значення змінної fruit з кожним значенням case послідовно. Якщо fruit дорівнює "apple", то виконується блок коду під case "apple":, і на екран виводиться "This is an apple."

#case "apple":
    print("This is an apple.")

Якщо fruit дорівнює "banana", то виведеться "This is a banana.", і так далі для "orange". Але якщо жоден з варіантів не відповідає значенням case (тобто fruit не є ні "apple", ні "banana", ні "orange"), то виконується блок коду під case _:.


Символ _ тут використовується як "заглушка" для вказівки на будь-які інші випадки, які не відповідають переліченим. У цьому випадку на екран виведеться "Unknown fruit.".

#case _:
    print("Unknown fruit.")


Цей оператор був введений для випадків, коли нам потрібно виконати різні дії в залежності від значення однієї змінної, особливо коли таких варіантів багато. Раніше для цього ми використовували довгий ланцюжок if-elif-else, але тепер оператор match робить код чистішим та простішим для розуміння.
 """


# Але оператор має більш розширену сферу використання. 
# Наприклад використання змінних у шаблонах. Розглянемо приклад:


point = (1, 0)

match point:
    case (0, 0):
        print("Точка в центрі координат")  
    case (0, y):
        print(f"Точка лежить на осі Y: y={y}")  
    case (x, 0):
        print(f"Точка лежить на осі X: x={x}") 
    case (x, y):
        print(f"Точка має координати:  x={x}, y={y}") 
    case _:
        print("Це не точка")


point = (2, 3)

match point:
    case (0, 0):
        print("Точка в центрі координат")  
    case (0, y):
        print(f"Точка лежить на осі Y: y={y}")  
    case (x, 0):
        print(f"Точка лежить на осі X: x={x}") 
    case (x, y):
        print(f"Точка має координати:  x={x}, y={y}") 
    case _:
        print("Це не точка")
 
""" Якщо значення point = (1, 0) то спрацює case (x, 0): і ми отримаємо виведення Точка лежить на осі X: x=1. Якщо значення point = (1, 1) то спрацює вже case (x, y): та буде вивід "Точка має координати: x=1, y=1". В прикладі використовується match для порівняння point з декількома шаблонами. Якщо point відповідає одному з цих шаблонів, виконується відповідний блок коду.
 """

# Також можна використовувати оператор match з колекціями. Наприклад ми маємо список pets, який містить назви домашніх тварин. """

pets = ["dog", "fish", "cat"]

match pets:
    case ["dog", "cat", _]:
        # Випадок, коли є і собака, і кіт
        print("There's a dog and a cat.")
    case ["dog", _, _]:
        # Випадок, коли є тільки собака
        print("There's a dog.")
    case _:
        # Випадок для інших комбінацій
        print("No dogs.")

""" 
В цьому випадку виведення буде "There's a dog.", бо тільки "dog" знаходиться на своєму місці. Тут match використовується для перевірки, чи містить список pets певні комбінації тварин. Причому важливо, що саме комбінації, і саме тому в нас спрацював case ["dog", _, _]:, а не case ["dog", "cat", _]:, бо cat в списку pets знаходиться в кінці, а не після dog. Знак _ в шаблоні використовується як "заповнювач", що означає "будь-яке інше значення".
"""


   ## Цикли

'''
Для того, щоб повторити якийсь блок коду кілька разів або повторювати, доки виконується деяка умова, у Python реалізовані цикли. Вони є фундаментальною конструкцією, яка дозволяє повторювати виконання певного блоку коду кілька разів.
Існують два основних типи циклів: for та while.:


Цикл for в Python використовується для ітерації по елементах будь-якої послідовності (наприклад, списку, кортежу, рядка) або інших ітерованих об'єктів;

for element in sequence:
    # виконувати дії з element


Цикл while виконує блок коду, поки задана умова є істинною (True). Як тільки умова стає неправдивою (False), цикл закінчується.

while condition:
    # виконувати дії, поки condition є True


Ітерація (лат. iteratio «повторювання») — повторювання будь-якої дії. Ітерація у програмуванні — організація обробки даних, за якої дії повторюються багаторазово, не призводячи, при цьому, до викликів самих себе. Одна ітерація — це одне повторювання.
'''

# Цикл for

'''
У Python цикл for використовується для перебору усіх елементів контейнерів або ітерованих об'єктів, наприклад, списків. Інструкції, які знаходяться у тілі циклу, будуть виконані стільки разів, скільки елементів у колекції.
При цьому на кожній ітерації спеціальна змінна набуває значення одного з елементів колекції.
Роботу циклу for можна порівняти з тим, що ви по черзі візьмете кожну літеру з фрази й промовите її. Фразою може виступати рядок 'apple', а аналогом вимовлення вголос буде виступати виведення відповідної літери в консоль.
'''

# fruit = 'apple'
# for char in fruit:
#     print(char)

'''
У результаті виконання цього коду ви побачите в консолі:

a
p
p
l
e

Синтаксис циклу for в Python включає кілька важливих компонентів:

Цикл починається з ключового слова for, що вказує на початок циклу.
Після for слідує назва змінної, яка буде використовуватися для зберігання поточного значення ітерації. Значення цієї змінної буде змінюватися з кожною ітерацією циклу.
Далі йде ключове слово in, що вказує на об'єкт або діапазон, по якому буде відбуватися ітерація.
Після in розміщується об'єкт або вираз, що визначає набір елементів або діапазон, по якому буде відбуватися ітерація.
В кінці рядка ставиться двокрапка :, що відділяє заголовок циклу від його тіла.
На новому рядку з відступом від початку рядка розміщуються інструкції або вирази, які потрібно виконувати на кожній ітерації. Відступ є обов'язковим, оскільки він визначає блок коду, який належить до циклу.

Розглянемо декілька прикладів, щоб краще розуміти як працює цикл for. По будь-якій колекції можна пройти за допомогою циклу for і на кожній ітерації в циклі буде отримано один з елементів цієї колекції.
'''

# alphabet = "abcdefghijklmnopqrstuvwxyz"
# for char in alphabet:
#     print(char, end=" ")

'''
У прикладі літери алфавіту з alphabet виводяться в консоль по черзі, через пробіл.



 a b c d e f g h i j k l m n o p q r s t u v w x y z



Використаємо цикл for у Python для ітерації по елементах ітерованого об'єкта, у нашому випадку — списку some_iterable.



✂️ Цей код можна запустити!

some_iterable = ["a", "b", "c"]

for i in some_iterable:
    print(i)



У консолі ми побачимо:



a
b
c



Цикл for використовується для послідовного проходження по кожному елементу списку some_iterable. В цьому циклі i є змінною, яка на кожній ітерації приймає значення поточного елемента з some_iterable. На кожній ітерації виконується команда print(i), яка виводить поточний елемент списку.



Цикл for може використовуватися для перебору всіх чисел у списку та отримання результату для кожного числа:



✂️ Цей код можна запустити!


odd_numbers = [1, 3, 5, 7, 9]
for i in odd_numbers:
    print(i ** 2)



Код з цього прикладу виведе в консоль квадрати чисел списку odd_numbers.



1
9
25
49
81



Розглянемо наступну задачу. Користувач вводить рядок. Треба порахувати скільки символів в рядку та скільки пробілів в рядку. Як ми можемо написати код?



Ми повинні скласти порядок дій для розв'язання цієї задачі:



Зчитування рядка від користувача.
Використання циклу for для перебору кожного символу в рядку.
Підрахунок загальної кількості символів та окремо кількості пробілів за допомоги циклу for та оператору if.


Ось приклад коду на Python, який реалізує цю логіку:



# Зчитування рядка від користувача
user_input = input("Введіть рядок: ")

# Ініціалізація змінних для підрахунку символів та пробілів
total_chars = len(user_input)  # загальна кількість символів у рядку
space_count = 0  # кількість пробілів

# Підрахунок кількості пробілів
for char in user_input:
    if char == " ":
        space_count += 1

# Виведення результатів
print(f"Загальна кількість символів у рядку: {total_chars}")
print(f"Кількість пробілів у рядку: {space_count}")



У цьому коді вираз len(user_input) використовується для підрахунку загальної кількості символів у введеному рядку. Цикл for проходить через кожен символ у рядку, і якщо символ є пробілом, умова char == " ", змінна space_count інкрементується (збільшується) на 1. В кінці, виводяться обидва результати - це загальна кількість символів та кількість пробілів.
'''

# Цикл while

'''
Цикл while у Python — це один із способів організації циклічного виконання коду. Він продовжує виконувати блок інструкцій, поки задана умова залишається істинною. Цикл while часто використовується, коли кількість ітерацій заздалегідь невідома або коли ітерації залежать від змінних, які можуть бути модифіковані в процесі виконання циклу.



Синтаксис циклу while наступний:



while condition:
    # Блок коду для виконання



condition (умова) — це логічний вираз, який перевіряється перед кожною ітерацією циклу. Якщо умова істинна True, код усередині блоку while виконується. Як тільки умова стає неправдивою False, виконання циклу припиняється.



Розглянемо приклад



✂️Цей код можна запустити!

k = 0
while k < 10:
    k = k + 1
	print(k)



У цьому прикладі, цикл while виконуватиметься, поки змінна k менша за 10. На кожній ітерації k збільшується на 1, і виводиться значення k. Коли змінна k досягає значення 10, умова k < 10 стає неправдивою, і цикл припиняється.






При використанні циклів while важливо забезпечити, що умова циклу змінюватиметься в процесі його виконання, щоб уникнути нескінченних циклів.

'''



# «Нескінченні цикли» та break

''''
Бувають ситуації, коли необхідно вийти з циклу до завершення ітерації, не дочекавшись, доки станеться чергова перевірка умови. Для цього є команда break. Команда break зупиняє цикл в момент виклику і не завершує ітерацію.



a = 0
while True:
    print(a)
    if a >= 20:
        break
    a = a + 1



В цьому прикладі умова циклу буде виконуватися завжди, адже True завжди буде True. Це приклад нескінченного циклу. Але через перевірку, що a >= 20, цей цикл завершиться, щойно в a буде значення 20 або більше.



Нескінченні цикли часто застосовуються там, де потрібно взаємодіяти з клієнтом, чекаючи введення від нього, і завершується тільки при настанні деякої умови.



Наприклад echo скрипт, який виводить в консоль те, що ви введете, доки ви не введете рядок тексту exit:



while True:
    user_input = input()
    print(user_input)
    if user_input == "exit":
        break
'''

# Завершення ітерації за допомогою continue

'''
Також для того, аби одразу перейти до наступної ітерації циклу без виконання виразів, що залишилися, є команда continue. Виклик цієї команди у тілі циклу призводить до того, що вирази цієї ітерації, що залишилися, не будуть виконані, а інтерпретатор одразу перейде до наступної ітерації або перевірки умови.



✂️ Цей код можна запустити!
'''
# a = 0
# while a < 6:
#     a = a + 1
#     if not a % 2:   # теж саме що a%2 != 0  a не ділиться без остачі на 2, тобто a є непарним числом
#         continue
#     print(a)


# a = 0
# while a < 6:
#     a = a + 1
#     if a % 2:   # теж саме що a%2 == 0  a ділиться без остачі на 2, тобто a є парним числом
#         continue
#     print(a)

'''

У консолі ви побачите:



1
3
5



Інструкція print(a) не виконувалась, коли a ділилося на 2 без залишку, оскільки ітерація завершувалася за допомогою continue.



В цьому прикладі використовувався оператор отримання залишку від ділення %, він повертає таке число p, що якщо його відняти від r, то результат буде ділитися на x націло: (r - p) / x = a, де а, x, r — цілі числа.



for i in range(1, 10):
    if i % 2 == 0:
        print(f”{i} є парним числом.“)
    else:
        print(f”{i} є непарним числом.“)



Оператори continue та break працюють тільки всередині одного циклу. В ситуації вкладених циклів немає способу вийти з усіх циклів одразу.



while True:
    number = input("number = ")
    number = int(number)
    while True:
        print(number)
        number = number - 1
        if number < 0:
            break



В цьому прикладі користувач вводить число та отримує зворотний відлік від цього числа до 0 в консолі. При цьому, зовнішній нескінченний цикл жодним чином не перервати і break вийде тільки з внутрішнього циклу.



Також використання continue або break поза циклом призводить до синтаксичної помилки.


# number = int(input("number = "))
# if number < 0:
#     break            # SyntaxError: 'break' outside loop



Такий код призводить до помилки SyntaxError. Такі помилки називаються винятками.
'''
# Розширення можливостей циклу for

'''

Зараз ми розглянемо три ключові функції Python, які забезпечують потужні і гнучкі способи для ітерації, або повторення певних дій: range, enumerate та zip.



Ці функції є фундаментальними для ефективного використання циклів for та відіграють важливу роль у різноманітних програмувальних задачах. Розуміння та застосування цих функцій допоможе підвищити ефективність нашого коду.



Функція range важлива для створення послідовностей чисел, які ви можете використовувати у циклах. Вона надзвичайно корисна, коли вам потрібно виконати дію певну кількість разів або ітерувати через послідовність чисел.
Коли вам потрібно отримати доступ не тільки до значення з ітерованої колекції, але до її індексу, тут функція enumerate стає незамінним помічником. Ця функція дозволяє вам легко отримувати доступ до індексу кожного елементу під час ітерації.
Функція zip використовується для одночасної ітерації по кількох колекціях. Якщо вам потрібно комбінувати дані з різних джерел або виконувати операції, які залежать від декількох пов'язаних колекцій, zip дозволяє це зробити легко та елегантно.


Розглянувши кожну з цих функцій, ми зможемо значно розширити свої навички роботи з циклами та колекціями в Python, створюючи більш потужний та виразний код.

'''

## Функція Range

'''
Функція range у поєднанні з циклом for у Python є потужним інструментом для контролю повторення дій певну кількість разів. Цей механізм часто використовується для ітерації через послідовність чисел, що робить його особливо корисним для різних задач, від базових до складних алгоритмів.



Функція range створює послідовність чисел. Вона може бути використана різними способами:



range(stop): Створює послідовність чисел від 0 до stop - 1.
range(start, stop): Генерує числа від start до stop - 1.
range(start, stop, step): Створює числа від start до stop - 1, з кроком step.





Цей приклад використовує цикл for разом з range для ітерації через послідовність чисел.



✂️ Цей код можна запустити!

for i in range(5):
    print(i)



У цьому прикладі range(5) генерує послідовність чисел від 0 до 4. Цикл for проходиться по цій послідовності, і змінна i приймає значення кожного числа в послідовності по черзі. Це був приклад простої ітерації.



Ітерація з визначеним початком і кінцем ітерації. Приклад виведення чисел від 2 до 9.



✂️ Цей код можна запустити!

for i in range(2, 10):
    print(i)



Ітерація з кроком. Цей приклад виведе парні числа від 0 до 8.



✂️ Цей код можна запустити!

for i in range(0, 10, 2):
    print(i)



Функція range разом з циклом for є основою для структурованого повторення коду та важливою частиною багатьох алгоритмів і програм у Python. Вони дають можливість легко маніпулювати послідовностями чисел для вирішення різноманітних задач.
'''



# Функція Enumerate

'''
Функція enumerate використовується для одночасного отримання індексу та значення елементів ітерованого об'єкта. Це корисно, коли вам потрібно отримати доступ до індексу елементів під час ітерації.






✂️ Цей код можна запустити!

some_list = ["apple", "banana", "cherry"]
for index, value in enumerate(some_list):
    print(index, value)



У цьому прикладі enumerate(some_list) створює пари індекс-значення для кожного елемента в списку, і цикл for проходить по цих парах.

Виведення:



0 apple
1 banana
2 cherry
'''




# Функція Zip

'''
Функція zip використовується для ітерації по декількох ітерованих об'єктах одночасно. Вона "застібає" елементи з кожного ітерованого об'єкта, створюючи кортежі з цих елементів.






✂️ Цей код можна запустити!
'''
# list1 = ["зелене", "стигла", "червоний"]
# list2 = ["яблуко", "вишня", "томат"]
# for number, letter in zip(list1, list2):
#     print(number, letter)

# a = zip(list1, list2)
# print(a)
'''


У цьому випадку zip(list1, list2) об'єднує елементи з list1 та list2, і цикл for проходить по створеним словосполученням.

Виведення:



зелене яблуко
стигла вишня
червоний томат



Коли колекції, передані в zip, мають різну довжину, zip обробляє елементи до тих пір, поки не закінчаться елементи в найкоротшій колекції. Це означає, що ітерація припиняється, як тільки буде досягнутий кінець однієї з колекцій, і будь-які додаткові елементи в інших, більш довгих колекціях, ігноруються.



✂️ Цей код можна запустити!

list1 = [1, 2, 3]
list2 = ['a', 'b', 'c', 'd', 'e']

for number, letter in zip(list1, list2):
    print(number, letter)



У цьому прикладі list1 має 3 елементи, тоді як list2 має 5 елементів. Оскільки list1 є коротшим, zip припинить ітерацію після третьої пари значень. Результат буде:



1 a
2 b
3 c



Елементи 'd' та 'e' з list2 у цьому випадку будуть проігноровані.



Тому обережно використовуйте zip з дуже великими колекціями, оскільки надлишкові елементи ігноруються, що може призвести до втрати даних або непередбачених результатів, якщо цей аспект ігнорувати.

list1 = ["зелене", "стигла", "червоний"]
list2 = ["яблуко", "вишня", "томат"]
for number, letter in zip(list1, list2):
    print(number, letter)


list1 = ["зелене", "стигла", "червоний"]
list2 = ["яблуко", "вишня", "томат"]
list3 = ["кисле", "смачна", "красивий"]
for number, letter, featuresss in zip(list1, list2, list3):
    print(number, letter, featuresss)
'''
# Цикли та словники

'''
Ітерування за словником — це такий блок коду, який дуже часто зустрічається при програмуванні, тож корисно вміти це робити.



Спершу варто сказати, що словник сам по собі — це ітерований контейнер і за ним можна ітеруватися в циклі for без необхідності заводити якийсь зовнішній лічильник тощо. Створимо словник, в якому ключами будуть числа, а значеннями — числівники англійською:



numbers = {
    1: "one",
    2: "two",
    3: "three"
}



Тепер давайте просто пройдемо словником в циклі та виведемо, що нам повертає ітератор на кожній ітерації:



✂️ Цей код можна запустити!

for key in numbers:
    print(key)

У виведенні ви побачите:

1
2
3



Ітеруючи за словником, ви перебираєте ключі словника. Таку саму поведінку можна отримати, використовуючи метод keys, але так ви явно вкажете, що хочете перебрати ключі:



✂️ Цей код можна запустити!

for key in numbers.keys():
    print(key)



Відповідь буде точно такою самою:



1
2
3



Часто необхідно перебрати саме значення словника, для цього скористаємося методом values:



✂️ Цей код можна запустити!

for val in numbers.values():
    print(val)



У виведенні буде:



one
two
tree






Щоб перебрати пари ключ значення словника треба використати метод items. На кожній ітерації ми отримаємо пару (ключ, значення):



✂️ Цей код можна запустити!

for key, value in numbers.items():
    print(key, value)



Виведення:



1 one
2 two
3 three






Важливо пам'ятати, що не можна робити, поки ітеруєтеся за словником: не можна видаляти елементи із словника, не можна додавати елементи у словник. Але можна перезаписувати значення, якщо ви ітеруєтеся за ключами. Теж саме стосуються і списку - не можна видаляти елементи списку та не можна додавати елементи у список під час ітерацій в циклі.

'''



     ## Винятки

'''
Перетворити в int або float можна не будь-який рядок. Наприклад, якщо користувач введе 'a', то інтерпретатор не зможе визначити, як перетворити символ a в ціле число, і викличе виняток ValueError.



int("a")
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-6-d9136db7b558> in <module>
----> 1 int("a")

ValueError: invalid literal for int() with base 10: 'a'




Виключення у Python — це помилка на рівні інтерпретатора, викликана неможливістю виконати той або інший оператор з будь-яких причин (змінна не існує, синтаксична помилка, відсутній атрибут, операція ділення на нуль тощо).



У нашому прикладі (ввели 'а') інтерпретатор намагається перетворити рядок в тип int (ціле число), але як перетворити рядок 'a' у число не визначено і буде викликаний виняток із цього приводу.
'''




# Основні типи винятків у Python

'''
SyntaxError — синтаксична помилка.

IndentationError — помилка, яка виникає, якщо у виділенні блоків інструкцій пробілами допущена помилка.

TabError виникає, якщо в одному файлі використовувати пробіли і табуляції для виділення блоків інструкцій.

TypeError виникає, коли операція зі змінною цього типу неможлива.



2 / 'a'



ValueError виникає, коли тип операнда відповідний, але значення таке, що операцію неможливо виконати.



int("a")



ZeroDivisionError — ділення на нуль.
'''




# Механізм обробки винятків

'''
Для обробки винятків існує оператор try ... except .... Синтаксично цей оператор розпочинається з ключового слова try: (спробувати) та продовжується блоком коду, в якому ми чекаємо, що може статися помилка.



Далі йде блок обробки винятків except (крім), де можна вказати один або більше винятків. Якщо один із зазначених винятків станеться, то виконається наступний блок коду.



Цей блок не обов'язковий, але найчастіше потрібний. Він виконається, якщо станеться зазначений виняток (один із них, якщо їх декілька).



Якщо помилки можуть бути різні і обробляти їх потрібно теж по-різному, то можна додати декілька блоків except, у кожному вказати свою помилку і що робити, якщо вона станеться.



Потім іде необов'язковий блок, який розпочинається з ключового слова else. Цей код виконається, тільки якщо винятків не сталося.



Останнім іде необов'язковий блок коду, який розпочинається з ключового слова finally, він виконається у будь-якому разі, незалежно від того, були помилки або ні.



У нашому прикладі обробка призначеного для користувача введення виглядатиме таким чином:



✂️ Цей код можна запустити!

val = 'a'
try:
    val = int(val)
except ValueError:
    print(f"val {val} is not a number")
else:
    print(val > 0)
finally:
    print("This will be printed anyway")



Винятки у Python — це дуже потужний інструмент, який часто використовується для управління потоком виконання, а не тільки для обробки помилок. У динамічних мовах ніколи не можна бути на 100% впевненим у тому, що користувач увів значення коректного типу, або що інший застосунок не повернув None замість int, наприклад.



Наївним розв'язанням цієї проблеми буде повсюдне використання перевірок if на коректність введеного користувачем або іншим застосунком значення. Просунутішим, зручнішим і прозорішим рішенням є використання механізму обробки винятків там, де вони можуть статися через некоректні вхідні дані.



age = input("How old are you? ")
try:
    age = int(age)
    if age >= 18:
        print("You are adult.")
    else:
        print("You are infant")
except ValueError:
    print(f"{age} is not a number")

'''

      ### Функції, область видимості змінних (LEGB)

'''
Функції – це спосіб групування коду, який виконує певну задачу. Вони дозволяють групувати код так, щоб його можна було викликати кілька разів у програмі без необхідності його повторного написання. Функції допомагають організувати код, роблять його більш читабельним і полегшують подальшу роботу з кодом.
'''

  ## Створення та виклик функцій

'''
Функція оголошується за допомогою ключового слова def. Після ключового слова вказується ім'я функції, за яким йде пара дужок (), у яких можна вказати імена деяких змінних, та двокрапка : в кінці рядка. Далі слідує блок команд, що складають функцію. На прикладі можна бачити, що насправді це дуже просто:



✂️ Цей код можна запустити!

def say_hello():
		# тіло функції
    print('Привіт, Світ!')

# Кінець функції say_hello()

# виклик функції
say_hello()

# ще один виклик функції
say_hello()



Ми визначили функцію з ім'ям say_hello, використовуючи описаний вище синтаксис. Ця функція не приймає параметрів, тому в дужках не оголошені якісь змінні.




'''

  ## Аргументи функції
'''
Параметри функції – це деякі вхідні дані, які ми можемо передати функції, щоб отримати результат, що відповідає цим даним.



Функції можуть приймати параметри, тобто деякі значення, що передаються в середину функції для того, щоб вона щось зробила з ними. Ці параметри схожі на змінні, за виключенням того, що значення цих змінних вказуються при виклику функції, та під час роботи функції їм вже присвоєні їх значення.



Параметри вказуються в дужках при оголошенні функції та розділяються комами. Аналогічно ми передаємо значення, коли викликаємо функцію.



Зверніть увагу на термінологію: імена, вказані при оголошенні функції, називаються параметрами, тоді як значення, які ви передаєте у функцію при її виклику, – аргументами.



✂️ Цей код можна запустити!

def print_max(a, b):
    if a > b:
        print(a, 'максимально')
    elif a == b:
        print(a, 'дорівнює', b)
    else:
        print(b, 'максимально')

print_max(3, 4)  # пряма передача значень

x = 5
y = 7
print_max(x, y)  # передача змінних у якості аргументів



Тут ми визначили функцію з ім'ям print_max, яка використовує два параметри з іменами a та b. Ми знаходимо найбільше число із застосуванням простого оператора if..else та виводимо це число. При першому виклику функції print_max ми напряму передаємо числа як аргументи.



print_max(3, 4)  # пряма передача значень



У другому випадку ми викликаємо функцію зі змінними як аргументи, print_max(x, y) призначає значення аргументу x параметру a, а значення аргументу y – параметру b.



x = 5
y = 7
print_max(x, y)  # передача змінних у якості аргументів



В обох випадках функція print_max працює однаково.
'''

  ## Типізація параметрів функції
'''
В Python, починаючи з версії 3.5, ви можете використовувати "type hints" (підказки типів) для вказівки очікуваних типів параметрів. Це дозволяє коду бути більш зрозумілим та може допомогти у виявленні можливих помилок.



Попередню функцію ми можемо записати тепер наступним чином:



✂️ Цей код можна запустити!

def print_max(a: int, b: int):
    if a > b:
        print(a, 'максимально')
    elif a == b:
        print(a, 'дорівнює', b)
    else:
        print(b, 'максимально')

print_max(3, 4)  # пряма передача значень

x = 5
y = 7
print_max(x, y)  # передача змінних у якості аргументів



У цьому прикладі параметри a: int та b: int позначають, що функція print_max очікує два аргументи типу int (цілі числа). Типізація параметрів допоможе нам зробити очікування функції щодо вхідних даних більш явними.



Типізація в Python є опціональною та не впливає на виконання коду в рантаймі (run-time), але вона може бути корисною для розробників. Це дозволяє легше розуміти код, забезпечує кращу підтримку від редакторів коду, а також полегшує виявлення помилок перед виконанням коду.
'''

  ## Повернення результату
'''
У Python немає синтаксичної різниці між функціями і процедурами. По суті, функція вміє повертати деякий результат своєї роботи, а процедура нічого не повертає та результатом її роботи може бути зміна стану вже існуючих змінних. Така форма використання функцій максимально наближена до функцій, з якими ми знайомі з уроків математики.



Повернення результату з функції в Python виконується за допомогою оператора return. Цей оператор завершує виконання функції та "повертає" значення, яке може бути використане в інших частинах програми. Це особливо корисно для отримання результатів обчислень, обробки даних та інших операцій. В Python ви можете явно вказати тип даних, який повертається функцією, використовуючи анотації типів.



Базовий синтаксис для повернення значення з функції виглядає наступним чином:



def my_function() -> ReturnType:
    # виконати дії
    return result



ReturnType вказує на тип даних, який функція має повертати. Це може бути будь-який тип даних, як-от int, float, str, list, dict, або навіть складніші типи, включаючи класи та інтерфейси, що ми побачимо згодом в курсі. Для повернення значення з функції необхідно вказати, що повернути після ключового слова return. Тому result - це значення або змінна, яку функція повертає.



Розглянемо приклад функції, яка сумує два числа та повертає результат:



✂️ Цей код можна запустити!

def add_numbers(num1: int, num2: int) -> int:
    sum = num1 + num2
    return sum

result = add_numbers(5, 10)
print(result)  # Виведе: 15



У цьому прикладі, функція add_numbers приймає два цілих числа num1 та num2 та повертає їх суму. Тип значення який повертає функція вказаний як int.



Приклад функції, що повертає рядок:



✂️ Цей код можна запустити!

def greet(name: str) -> str:
    return f"Привіт, {name}!"

greeting = greet("Олексій")
print(greeting)  # Виведе: Привіт, Олексій!



Тут функція greet приймає рядок name та повертає привітання, також у форматі рядка.



Функція, що повертає булеве значення:



✂️ Цей код можна запустити!

def is_even(num: int) -> bool:
    return num % 2 == 0

check_even = is_even(4)
print(check_even)  # Виведе: True



Функція is_even перевіряє, чи число парне, і повертає результат булеве значення True або False.



Повернення значень з функцій є ключовим аспектом програмування, оскільки це дозволяє функціям не тільки виконувати певні дії, але й комунікувати результатами цих дій з іншими частинами програми.
'''

  ## Принципи змінності об'єктів у Python
'''
У Python всі об'єкти передаються за посиланням, але важливо розуміти різницю між змінними (mutable) та незмінними (immutable) типами даних, адже від цього залежить, як відбувається передача об'єктів та які помилки можуть виникати.



Незмінні типи в Python — це ті, що не можуть бути змінені після їх створення. Це включає типи, як-от цілі числа int, дійсні числа float, рядки str, кортежі tuple.



Коли незмінний об'єкт передається у функцію, фактично передається його копія, і будь-які зміни цього об'єкту в функції не впливають на оригінальний об'єкт.



Розглянемо наступний приклад:



✂️ Цей код можна запустити!

def modify_string(original: str) -> str:
    original = "змінено"
    return original

str_var = "оригінал"
print(modify_string(str_var))  # виведе: змінено
print(str_var)                # виведе: оригінал



У цьому прикладі, навіть після зміни рядка в функції modify_string, оригінальна змінна str_var залишається незмінною.



Змінні типи, як списки list, словники dict, множини set, можуть змінюватися. Коли змінний об'єкт передається у функцію, передається посилання на цей об'єкт, і зміни, зроблені всередині функції, відображаються на оригінальному об'єкті.



Подивимось наступний приклад зі змінними типами:



✂️ Цей код можна запустити!

def modify_list(lst: list) -> None:
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # виведе: [1, 2, 3, 4]



Тут зміни всередині функції modify_list впливають на оригінальний список my_list. Отже, ми передали в функцію modify_list наш список my_list і після виконання функції modify_list(my_list) сам список змінився.



Змінні об'єкти, передані у функції, можуть змінитися несподівано. Це може привести до помилок, особливо якщо ви не очікуєте, що об'єкт буде змінено.



При "копіюванні" змінного об'єкта шляхом простого присвоєння new_list = old_list ви копіюєте посилання, а не сам об'єкт. Це означає, що зміни в одному списку відображатимуться й у іншому. Фактично в середині функції modify_list відбулося присвоювання lst = my_list



Перед тим, як передавати змінні об'єкти, такі як списки або словники у функцію, важливо зважати на те, чи плануєте ви змінювати ці об'єкти в функції. Якщо вам потрібно залишити оригінальний об'єкт без змін, розгляньте можливість створення копії. Бо якщо ви передаєте змінний об'єкт (наприклад, список) у функцію та модифікуєте його всередині функції, оригінальний список теж зміниться.



Використовуйте метод copy() для створення копій змінних об'єктів, якщо не хочете змінювати оригінал.



✂️ Цей код можна запустити!

def modify_list(lst: list) -> None:
    lst = lst.copy()
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # виведе: [1, 2, 3]



Тут список my_list після виконання функції modify_list вже не зазнає змін.
'''




## Задача на функцію
'''

Для закріплення отриманих знань, розглянемо наступний приклад. Уявімо, що перед нами стоїть задача: конвертувати кожен символ у рядку в його відповідний код ASCII. Це класична задача, що демонструє взаємодію з рядками в Python та їх обробку.



Спершу вирішимо, де будемо зберігати ці коди. Один з найкращих варіантів - це використання словника dict, оскільки він дозволяє зберігати пари ключ-значення. У нашому випадку, ключем буде символ, а значенням - його код ASCII.

Для отримання числового коду символу ми будемо використовувати вбудовану функцію ord(). Ця функція приймає один символ і повертає його код ASCII. Наприклад, ord('A') повертає 65, оскільки 65 - це код ASCII для символу 'A'.

Рядки в Python - це ітеруємі об'єкти, що означає, що ми можемо пройтися по кожному символу рядка, використовуючи цикл for. Це ідеально підходить для нашої задачі, адже нам потрібно обробити кожен символ окремо.



Для більшої гнучкості та можливості повторного використання коду ми обгорнемо нашу логіку в функцію. Це дасть нам змогу легко використати цей функціонал із різними рядками ще не один раз.



def string_to_codes(string: str) -> dict:
    # Ініціалізація словника для зберігання кодів
    codes = {}  
    # Перебір кожного символу в рядку
    for ch in string:  
        # Перевірка, чи символ вже є в словнику
        if ch not in codes:
            # Додавання пари символ-код в словник  
            codes[ch] = ord(ch)  
    return codes



Ми створюємо пустий словник codes, де будемо зберігати наші пари символ-код. Далі за допомогою циклу for ми ітеруємося по кожному символу ch у вхідному рядку string. В середині циклу перевіряємо кожен символ рядка, чи вже присутній він у словнику? Якщо ні, використовуємо вбудовану функцію ord(ch) для отримання коду ASCII цього символу та додаємо цю пару до словника codes. Після завершення циклу повертаємо словник codes.



Після виклику функції string_to_codes із рядком "Hello world!", отримуємо словник, де кожен унікальний символ рядка відображений на його числовий код ASCII.



✂️ Цей код можна запустити!

result = string_to_codes("Hello world!")
print(result)



Виведення:



{'H': 72, 'e': 101, 'l': 108, 'o': 111, ' ': 32, 'w': 119, 'r': 114, 'd': 100, '!': 33}



Цей приклад показує, як можна об'єднати знання про рядки, словники, цикли та функції для розв'язання конкретних завдань в Python.
'''


  ## Області видимості (LEGB)

'''
Область видимості — це область у програмі (коді), в межах якої ви можете звернутися за ім'ям до вмісту змінної. Ці області видимості діляться на чотири рівні в порядку пошуку імен змінних, та відомі як LEGB-правило:



L - Local (Локальна): Це внутрішній рівень, де ім'я визначено всередині функції або блоку коду.
E - Enclosing (Охоплювана): Це область видимості, яка охоплює локальну область видимості. Якщо функція знаходиться всередині іншої функції, імена, визначені в охоплюваній функції, будуть доступні для внутрішньої функції.
G - Global (Глобальна): Це область видимості на рівні модуля або сценарію. Змінні, визначені на цьому рівні, доступні у всьому модулі.
B - Built-in (Вбудована): Це самий зовнішній рівень, який містить імена, вбудовані в Python. Наприклад розглянуті нами вбудовані функції, len, range тощо.
'''



# Local
'''

У Python кожна змінна, оголошена всередині функції, є локальною для цієї функції. Це означає, що локальні змінні існують лише в межах блоку коду, де вони були оголошені, і не доступні за його межами.



✂️ Цей код можна запустити!

x = 50

def func() -> None:
    x = 2
    print('Зміна локального x на', x)  # Зміна локального x на 2

func()
print('Глобальний x як і раніше', x)  # x як і раніше 50



Змінна x, оголошена всередині функції func, є локальною. Коли ми присвоюємо їй значення 2, це не впливає на глобальну змінну x, оголошену поза функцією. Тому, після виклику func(), виведення залишає глобальне значення x (яке дорівнює 50) незмінним.



Останнім викликом функції print ми виводимо значення x, вказане в основному блоці, підтверджуючи таким чином, що воно не змінилося при локальному присвоюванні значення в раніше викликаній функції.



Виведення:



Зміна локального x на 2
Глобальний x як і раніше 50
'''




# Enclosing
'''

Охоплювана (Enclosing) область видимості виникає, коли функція визначена всередині іншої функції. Змінні в функції, що охоплює доступні у внутрішній (вкладеній) функції, але не навпаки. Це означає, що внутрішня функція може читати але не змінювати змінні, визначені в функції, що її охоплює.



Розглянемо наступний приклад:



✂️ Цей код можна запустити!

def outer_func():
    enclosing_var = "Я змінна в функції, що охоплює"

    def inner_func():
        print("Всередині вкладеної функції:", enclosing_var)

    inner_func()

outer_func()



Виведення:



Всередині вкладеної функції: Я змінна в функції, що охоплює



Тут enclosing_var є змінною в функції outer_func, що охоплює функцію inner_func. Вона доступна для читання в вкладеній функції inner_func, але не може бути змінена в inner_func без використання ключового слова nonlocal.



Для того, щоб розібратися як змінювати змінні в функції, що охоплює внутрішню функцію, розглянемо приклад:



def func_outer():
    x = 2

    def func_inner():
        nonlocal x
        x = 5

    func_inner()
    return x

result = func_outer()  # 5



Коли ми перебуваємо всередині функції func_inner, змінна x, визначена у першому рядку функції func_outer, знаходиться в enclosing області видимості для неї. Якщо ми захочемо використати саме цю змінну x, ми повинні оголосити її nonlocal x всередині функції func_inner. Це означає, що змінна x, яку вона буде змінювати, є не локальною для func_inner, а знаходиться на більш високому рівні — в нашому випадку, в func_outer. Тому, коли func_inner змінює x на 5, ця зміна відображається на x в func_outer.



Тому результат result дорівнюватиме 5, а не 2, оскільки всередині функції func_outer ми зробили виклик func_inner(), яка змінила x з 2 на 5.
'''




# Global
'''
Для того, щоб змінити глобальну змінну всередині функції, необхідно використовувати ключове слово global. Це вказує Python, що змінна не є локальною, а належить до глобальної області видимості. Без застосування зарезервованого слова global неможливо присвоїти значення змінній, визначеній за межами функції.



✂️ Цей код можна запустити!

x = 50

def func():
    global x
    print('x дорівнює', x)  # x дорівнює 50
    x = 2
    print('Змінюємо глобальне значення x на', x)  # Змінюємо глобальне значення x на 2

func()
print('Значення x складає', x)# Значення x складає 2




Виведення:

x дорівнює 50
Змінюємо глобальне значення x на 2
Значення x складає 2



Зарезервоване слово global використовується для того, щоб оголосити, що x – це глобальна змінна, а значить, коли ми присвоюємо значення імені x всередині функції, ця зміна відобразиться на значенні змінної x в основному блоку програми. Використовуючи одне зарезервоване слово global, можна оголосити відразу декілька змінних: global x, y, z.



Використовувати global варто з великою обережністю і не потрібно зловживати такою можливістю.



Розуміння цих основних принципів є важливим для ефективного написання коду та уникнення помилок, пов'язаних із неправильним використанням змінних. Локальні змінні корисні для забезпечення інкапсуляції даних всередині функцій, тоді як глобальні змінні дозволяють зберігати дані, які потрібні на різних етапах виконання програми.


'''
## Ключові аргументи функції
'''
Якщо є деяка функція з великою кількістю параметрів, і при її виклику вимагається вказати тільки деякі з них, значення цих параметрів можуть задаватися за їх ім'ям. Це називається ключовими параметрами.



Ключові аргументи в функціях Python — це спосіб передачі аргументів функції, при якому кожному аргументу присвоюється ім'я. Це дозволяє вказувати аргументи у будь-якому порядку під час виклику функції, не дотримуючись порядку, визначеного у її оголошенні. Ключові аргументи роблять код більш читабельним та дозволяють використовувати значення за замовчуванням для деяких аргументів.



Визначимо функцію з ключовими аргументами



✂️ Цей код можна запустити!

def greet(name, message="Привіт"):
    print(f"{message}, {name}!")



У цьому прикладі name — це позиційний параметр, а message — ключовий параметр зі значенням за замовчуванням "Привіт". При виклику функції можна не вказувати message, і тоді буде використано значення за замовчуванням.



# використовує значення за замовчуванням для message
greet("Олексій")  

# передача власного значення для message
greet("Марія", message="Добрий день")  



Виведення:



Привіт, Олексій!
Добрий день, Марія!



У першому виклику ми передаємо тільки name, а у другому — і name, і message.

Розглянемо наступний приклад для демонстрації гнучкості ключових аргументів, та можливості змінювати порядок аргументів або використовувати значення за замовчуванням.



✂️ Цей код можна запустити!

def func(a, b=5, c=10):
    print('a дорівнює', a,', b дорівнює', b,', а c дорівнює', c)

# a дорівнює 3, b дорівнює 7, а c дорівнює 10
func(3, 7)

# a дорівнює 25, b дорівнює 5, а c дорівнює 24
func(25, c=24)

# a дорівнює 100, b дорівнює 5, а c дорівнює 50
func(c=50, a=100)



Виведення:



a дорівнює 3 , b дорівнює 7 , а c дорівнює 10
a дорівнює 25 , b дорівнює 5 , а c дорівнює 24
a дорівнює 100 , b дорівнює 5 , а c дорівнює 50



Функція з ім'ям func має один параметр без значення за замовчуванням, за яким слідують два параметри зі значеннями за замовчуванням. При першому виклику func(3, 7), параметр a отримує значення 3, параметр b отримує значення 7, а c отримує своє значення за замовчуванням, що дорівнює 10.



При другому виклику func(25, c=24) змінна a отримує значення 25 на підставі позиції аргументу. Після цього параметр c отримує значення 24 за ім'ям, тобто як ключовий параметр. Змінна b отримує значення за замовчуванням, що дорівнює 5.



При третьому зверненні func(c=50, a=100) ми використовуємо ключові аргументи для усіх вказаних значень. Зверніть увагу на те, що ми вказуємо значення для параметра c перед значенням для a, навіть попри те, що у визначенні функції параметр a вказаний раніше c.



Ключові аргументи роблять функції більш гнучкими та підвищують читабельність коду, особливо коли функція має багато параметрів або коли деякі параметри мають зрозумілі значення за замовчуванням. Це також дозволяє уникнути помилок, що можуть виникнути через неправильний порядок аргументів при виклику функції.



Функція з ім'ям say використовується для виведення на екран рядка, вказаного число разів.



✂️ Цей код можна запустити!

def say(message, times=1):
    print(message * times)

say('Привіт') 
say('Світ', 5)



Якщо ми не вказуємо значення за замовчуванням, рядок виводиться один раз. Ми досягаємо цього задавши значення аргументу за замовчуванням, що дорівнює 1 для параметра times. При першому виклику say ми вказуємо тільки рядок, і функція виводить його один раз. При другому виклику say ми вказуємо також і аргумент, позначаючи таким чином, що ми хочемо сказати фразу 5 разів.



Значеннями за замовчуванням можуть бути забезпечені тільки параметри, що знаходяться у кінці списку параметрів. Таким чином, у списку параметрів функції параметр зі значенням за замовчуванням не може передувати параметру без значення за замовчуванням. Це пов'язано з тим, що значення надаються параметрам відповідно до їх положення. Наприклад, def func(a, b=5) — допустимо, а def func(a=5, b) – не допустимо та призведе до помилки в коді.



Розглянемо типову задачу, яка відображає реальну ситуацію в області торгівлі та фінансів, де потрібно часто обраховувати ціни зі знижками. Нам необхідно створити функцію для розрахунку вартості товарів з урахуванням можливої знижки.



Для розрахунку реальної ціни з врахуванням дисконту створимо функцію real_cost. Функція real_cost повинна приймати два аргументи: базову ціну товару base та розмір знижки discount, який за замовчуванням будемо вважати 0. Вона повинна повертати вартість товару після застосування знижки.



def real_cost(base: int, discount: float = 0) -> float:
    return base * (1 - discount)



Функція використовує формулу base * (1 - discount) для обрахунку остаточної вартості. Якщо знижка відсутня, то використовується лише базова ціна.



Ціна на хліб price_bread завжди без знижки і вона не застосовується, тому при визові функції real_cost використовується лише базова ціна. Для масла price_butter та цукру price_sugar застосовуємо знижки 5% та 7% відповідно.



price_bread = 15
price_butter = 50
price_sugar = 60

current_price_bread = real_cost(price_bread)
current_price_butter = real_cost(price_butter, 0.05)
current_price_sugar = real_cost(price_sugar, 0.07)



Вивід результатів



print(f'Нова вартість хліба: {current_price_bread}')
print(f'Нова вартість масла: {current_price_butter}')
print(f'Нова вартість цукру: {current_price_sugar}')



Виведення:



Нова вартість хліба: 15
Нова вартість масла: 47.5
Нова вартість цукру: 55.8



Функція real_cost показує, як можна використовувати функції та параметри за замовчуванням для обрахунку цін зі знижками. Це приклад того, як прості програмувальні концепції можуть бути застосовані для вирішення реальних бізнес-задач.
'''
## Змінна кількість параметрів
'''
Змінна кількість параметрів у функції в Python дозволяє функції приймати нефіксовану кількість аргументів. Це корисно у ситуаціях, коли ви хочете дозволити передавати різну кількість параметрів у свою функцію.



У Python існує два способи реалізації змінної кількості параметрів.



Параметр *args. Він дозволяє функції приймати довільну кількість позиційних аргументів. Аргументи, передані функції, зберігаються у вигляді кортежу.
Параметр **kwargs. Він дозволяє функції приймати довільну кількість ключових аргументів. Але аргументи, передані функції, зберігаються вже у вигляді словника.



'''
## Приклад використання параметру *args
'''
Спочатку розглянемо приклад *args. Параметр *args використовується у визначенні функції для вказівки на те, що функція може приймати довільну кількість позиційних аргументів. Це означає, що ви можете передавати в функцію стільки аргументів, скільки потрібно, без необхідності їх попереднього визначення.



✂️ Цей код можна запустити!

def print_all_args(*args):
    for arg in args:
        print(arg)

print_all_args(1, 'hello', True)



Виведення:



1
hello
True



У цьому прикладі, функція print_all_args може приймати будь-яку кількість аргументів. Аргументи 1, 'hello', та True передаються у функцію як кортеж і в середині функції змінна args зберігає кортеж (1, 'hello', True).



Де це може знадобиться? Насправді багато де, але ми розглянемо дуже простий та зрозумілий приклад. Нам треба написати функцію, яка буде передану будь яку кількість рядків об'єднувати в один рядок та повертати його.



✂️ Цей код можна запустити!

def concatenate(*args) -> str:
    result = ""
    for arg in args:
        result += arg
    return result

print(concatenate("Hello", " ", "world", "!"))



Виведення:



Hello world!



У цьому прикладі, функція concatenate може приймати будь-яку кількість рядкових аргументів, які потім конкатенуються в один рядок. Під час виклику функції, всі позиційні аргументи, передані після останнього визначеного аргументу, будуть упаковані в кортеж під ім'ям, що йде після символу * і зазвичай це ім'я args, але може бути будь-яке інше ім'я. Наступний приклад теж працюватиме але загально прийнято називати цей параметр args:



✂️ Цей код можна запустити!

def concatenate(*strings) -> str:
    result = ""
    for arg in strings:
        result += arg
    return result

print(concatenate("Hello", " ", "world", "!"))



Ми замінили назву параметру args на strings і в нас все продовжує працювати.

Отже підіб'ємо короткий підсумок - параметр *args використовується у визначенні функції для вказівки на те, що функція може приймати довільну кількість позиційних аргументів. Це означає, що ви можете передавати в функцію стільки аргументів, скільки потрібно, без необхідності їх попереднього визначення.




'''
## Приклад використання параметру **kwargs
'''
Параметр **kwargs використовується у визначенні функції для вказівки на те, що функція може приймати довільну кількість ключових аргументів. Назва kwargs пішла від "keyword arguments" та дозволяє передавати в функцію іменовані аргументи у вигляді словника.



Під час виклику функції, всі ключові аргументи, передані після останнього визначеного аргументу, будуть упаковані в словник під ім'ям, що йде після ** та зазвичай це kwargs, але, як і випадку args, може бути будь-яке інше ім'я.



✂️ Цей код можна запустити!

def greet(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

greet(name="Alice", age=25)



Виведення:



name: Alice
age: 25



У цьому прикладі, greet може приймати будь-яку кількість ключових аргументів, які потім обробляються і виводяться. В середині функції змінна kwargs зберігає словник, в нашому випадку це {'name': 'Alice', 'age': 25}.



Якщо виникає питання коли використовувати ці параметри, то параметр *args ми використовуємо коли хочемо дозволити передавати функції різну кількість позиційних аргументів. Параметр **kwargs — коли ми хочемо дозволити передавати функції різну кількість ключових аргументів.



Проте ніхто не забороняє параметри *args та **kwargs використовувати разом у функції, що дозволяє їй приймати довільну кількість як позиційних, так і ключових аргументів. Це робить функцію надзвичайно гнучкою. Головне пам'ятати, що коли ви використовуєте обидва ці параметри разом, *args має йти перед **kwargs. Тоді параметр *args збере всі позиційні аргументи в кортеж, а **kwargs збере всі ключові аргументи в словник.



✂️ Цей код можна запустити!

def example_function(*args, **kwargs):
    print("Позиційні аргументи:", args)
    print("Ключові аргументи:", kwargs)

example_function(1, 2, 3, name="Alice", age=25)



Виведення:



Позиційні аргументи: (1, 2, 3)
Ключові аргументи: {'name': 'Alice', 'age': 25}



При виклику example_function аргументи 1, 2, 3 є позиційними, які параметр *args збере в кортеж (1, 2, 3). Аргументи name="Alice" та age=25 є ключовими, які **kwargs збере в словник {'name': 'Alice', 'age': 25}



В майбутньому ви побачите, що ці методи роблять ваші функції значно більш гнучкими та здатними обробляти різні сценарії виклику. Використання *args та **kwargs разом надзвичайно корисне в ситуаціях, де вам буде потрібно передати різноманітні аргументи в функцію, особливо коли ви почнете писати API, декоратори або обгортки навколо інших функцій і ви не зможете передбачити, як саме інші розробники будуть використовувати ваші функції.



❗ Завжди використовуйте *args перед **kwargs у визначенні функції, оскільки це обов'язкове правило синтаксису Python.



'''
## Розпакування списків та словників
'''
Давайте розглянемо можливості операторів * та **. Їх використовують для розпаковки списків та словників. Розпакування списків та словників в Python — це потужна можливість, яка дозволяє присвоїти значення зі списку або словника до змінних одним рядком коду. Ця функція значно спрощує роботу з колекціями даних.



Розпакування списку дозволяє присвоїти елементи списку окремим змінним. Наприклад:



my_list = [1, 2, 3]
a, b, c = my_list



Тут a отримає значення 1, b отримає 2, і c отримає 3.

Якщо вам потрібно ігнорувати деякі з елементів списку під час розпакування, можна використовувати _:



a, _, c = my_list



У цьому прикладі a отримає 1, другий елемент списку буде ігноровано, і c отримає 3.



Можна також розпакувати частину списку, використовуючи *:



a, *rest = my_list



Тут a отримає перший елемент списку 1, а rest стане списком, що містить всі інші елементи та дорівнюватиме [2, 3].



Розпакування списків корисне, коли вам потрібно швидко присвоїти значення зі списку змінним або коли вам потрібно ігнорувати деякі з цих значень.

Розпакування словників працює трохи інакше і зазвичай використовується під час передачі аргументів у функцію.



def greet(name, age):
    print(f"Hello {name}, you are {age} years old.")

person_info = {"name": "Alice", "age": 25}
greet(**person_info)



У цьому прикладі **person_info розпаковує словник person_info, і його ключі та значення передаються як ключові аргументи в функцію greet.



Розпакування словників часто використовується для передачі іменованих аргументів у функції, особливо коли кількість аргументів або їхні імена не відомі заздалегідь.
'''
## Рекурсія
'''
Рекурсія — це концепція в програмуванні, коли функція викликає саму себе в рамках власного виконання. Це схоже на дроблення великої проблеми на менші, керованіші проблеми.



Розглянемо декілька простих прикладів рекурсивних функцій, таких як обчислення факторіала числа або чисел Фібоначчі.



Але спочатку нам треба визначити основні компоненти рекурсії:



Базовий випадок: Це умова, при якій рекурсія припиняє виклик самої себе, щоб уникнути нескінченного циклу. Він важливий для запобігання нескінченному циклу в рекурсії.
Рекурсивний випадок: Це умова, за якої функція викликає саму себе з новими аргументами. Фактично це ситуація, коли функція продовжує викликати саму себе, розбиваючи проблему на менші частини


Давайте розглянемо це на прикладі рекурсивної функції, яка обчислює факторіал числа.



Факторіал натурального числа 
n
n (позначається як 
n
!
n!) — це добуток всіх натуральних чисел від 1 до 
n
n включно.



Математичне визначення факторіала виглядає так:



n
!
=
{
1
 якщо 
n
=
0
n
×
(
n
−
1
)
!
 якщо 
n
>
0
n!={ 
1
n×(n−1)!
​
  
 якщо n=0
 якщо n>0
​
 


На основі цього визначення можна легко створити рекурсивну функцію для обчислення факторіала:



✂️ Цей код можна запустити!

def factorial(n):
    if n == 0: # базовий випадок
        return 1
    else:
        return n * factorial(n-1) # рекурсивний випадок

print(factorial(5)) # виведе 120



У цьому прикладі:



Базовий випадок: якщо n дорівнює 0, повернути 1. Це припиняє рекурсію, оскільки не відбувається додатковий виклик функції factorial.
Рекурсивний випадок: якщо n не дорівнює 0, повернути **n,**помножену на factorial(n-1). Ось тут і відбувається виклик функції factorial з аргументом, який на одиницю менший від поточного n, тому це є рекурсивний випадок.


Цей код працює тому, що кожен виклик factorial(n-1) працює на дедалі меншому числі аж до того моменту, коли n дорівнює 0, і відбувається базовий випадок. На цьому етапі рекурсія завершується, і результат починає "повертатися" назад через усі попередні виклики функції, обчислюючи добуток на кожному кроці.



Числа Фібоначчі — це послідовність чисел, у якій кожне наступне число є сумою двох попередніх. Перші два числа в цій послідовності, за визначенням, дорівнюють 0 і 1.



Математична формула для числа Фібоначчі:



F
(
n
)
=
{
0
 якщо 
n
=
0
1
 якщо 
n
=
1
F
(
n
−
1
)
+
F
(
n
−
2
)
 якщо 
n
>
1
F(n)= 
⎩
⎨
⎧
​
  
0
1
F(n−1)+F(n−2)
​
  
 якщо n=0
 якщо n=1
 якщо n>1
​
 



Рекурсивний підхід до обчислення чисел Фібоначчі базується на прямому застосуванні цього визначення. Ось як його можна реалізувати:



✂️ Цей код можна запустити!

def fibonacci(n):
    if n <= 1: # базовий випадок
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2) # рекурсивний випадок

print(fibonacci(10)) # виведе 55



Базовий випадок. Якщо 
n
≤
1
n≤1, функція просто повертає 
n
n. Це відповідає визначенню перших двох чисел Фібоначчі: 
F
(
0
)
=
0
F(0)=0 та 
F
(
1
)
=
1
F(1)=1.
Рекурсивний випадок. Якщо 
n
>
1
n>1, функція повертає суму двох попередніх чисел Фібоначчі, обчислених за допомогою рекурсивних викликів: 
F
(
n
−
1
)
F(n−1) та 
F
(
n
−
2
)
F(n−2).

Тут основна ідея в тому, що кожне число Фібоначчі є сумою двох попередніх чисел Фібоначчі (за винятком перших двох чисел). Тому щоб отримати $n$-е число Фібоначчі, вам потрібно додати 
(
n
−
1
)
(n−1) та 
(
n
−
2
)
(n−2) числа Фібоначчі. І цей процес продовжується рекурсивно, доки ви не дійдете до базового випадку.



Але що буде, якщо функція не матиме базового випадку і не повертатиме ніякого результату? Однією з потенційних проблем при використанні рекурсії є переповнення стеку. Якщо рекурсивні виклики функції продовжуються без досягнення базового випадку, стек викликів може переповнитись, що призведе до помилки виконання. Така помилка називається переповненням стеку (stack overflow, саме на її честь було названо популярний сайт https://stackoverflow.com). Багаторазові виклики функцій без повернення збільшують стек викликів доти, доки не буде витрачено всю виділену йому пам'ять комп'ютера.



Щоб цьому запобігти, інтерпретатори примусово завершують роботу програми після досягнення ліміту викликів функцій, які не повертають результат. Така межа називається максимальною глибиною рекурсії, або максимальним розміром стеку викликів. У Python граничним значенням вважається 1000 викликів функцій.




'''
## Стек викликів рекурсії
'''
Коли йдеться про рекурсію, ми зазвичай говоримо про функцію, яка викликає саму себе. Проте щоб краще зрозуміти, як рекурсія функціонує, потрібно зрозуміти, як комп'ютер обробляє виклики функцій взагалі. Тут ми стикаємося з поняттям "стек викликів".



Стек викликів — це специфічна частина пам'яті, яка використовується для зберігання інформації про активні виклики функцій. Кожен раз, коли функція викликається, створюється новий запис (або "шар") у цьому стеку для цього конкретного виклику. Цей шар містить інформацію про змінні функції, її параметри та місце, звідки була викликана функція, щоб після завершення виконання функції програма могла продовжити роботу з правильного місця.



Тож коли функція викликає себе рекурсивно, кожен новий виклик функції зберігається в стеку викликів. Сам стек викликів створює інтерпретатор Python під час виконання програми.



Якщо уявити стек як стопку книг, де кожна нова книга, яку ви кладете зверху, відображає новий виклик функції, то рекурсія — це додавання нових книг на верх стосу. Коли функція завершує свою роботу, "книга" знімається зі стосу, і ми "повертаємося" до попередньої книги.



Отже, коли базовий випадок досягнуто, виклики функцій починають "розвантажуватись" зі стеку, що дозволяє розрахувати кінцевий результат.

Розглянемо приклад коду, який показує, як працює стек викликів у рекурсії на прикладі функції для обчислення факторіала числа:



✂️ Цей код можна запустити!

def factorial(n):
    print("Виклик функції factorial з n = ", n)
    if n == 1:
        print("Базовий випадок, n = 1, повернення 1")
        return 1
    else:
        result = n * factorial(n-1)
        print("Повернення результату для n = ", n, ": ", result)
        return result

print(factorial(5))



Цей код обчислює факторіал числа 5, який дорівнює 5 * 4 * 3 * 2 * 1 = 120. Коли ви запустите цей код, ви побачите послідовність викликів рекурсивної функції і повернення результатів.



💡 Скопіюйте код і запустіть самостійно, щоб наочно подивитись, як він працює.


Цей приклад показує, як кожен виклик рекурсивної функції додає новий "шар" у стек викликів, а кожен повернений результат видаляє "шар". Базовий випадок (тут це n == 1) дозволяє завершити рекурсію і почати повертати результати.



Виконаємо поглиблений аналіз нашого прикладу з факторіалом та додамо ілюстрації.



Коли ви викликаєте factorial(5), створюється перший шар у стеку викликів для цього виклику. Оскільки ця функція викликає себе знову, створюється ще один шар стеку для factorial(4), потім ще один для factorial(3) і так далі, доки не буде досягнуто базового випадку factorial(1). У цей момент рекурсія досягла своєї найбільшої глибини, і стек викликів містить п'ять шарів.






Завершення виконання factorial(1) починає процес "розвантаження" стеку.



Кожен шар, починаючи з останнього, обробляється, і результат кожного виклику повертається до попереднього виклику, доки весь стек не буде оброблений, і ми не отримаємо кінцевий результат для factorial(5).






Рекурсивні функції зручні в ситуаціях, коли ми не знаємо заздалегідь, скільки разів потрібно буде викликати функцію, наприклад, при розборі директорій на диску. Застосунок не знає заздалегідь, наскільки глибока структура директорій і який у них рівень вкладеності. І щоб перебрати усі файли в усіх вкладених директоріях, функція повинна викликати сама себе, коли зустрічає чергову директорію. Така функція, яка викликає сама себе за деяких умов, називається рекурсивною.

'''




###################################################################



# def say_hello():
# 		# тіло функції
#     print('Привіт, Світ!')

# # Кінець функції say_hello()

# # виклик функції
# say_hello()

# # ще один виклик функції
# say_hello()


# def print_max(a, b):
#     if a > b:
#         print(a, 'максимально')
#     elif a == b:
#         print(a, 'дорівнює', b)
#     else:
#         print(b, 'максимально')

# print_max(3, 4)  # пряма передача значень

# x = 5
# y = 5
# print_max(x, y)  # передача змінних у якості аргументів



# def add_numbers(num1: int, num2: int) -> int:
#     sum = num1 + num2
#     return sum

# result = add_numbers(5, 10)
# print(result)  # Виведе: 15


# def greet(name: str) -> str:
#     return f"Привіт, {name}!"

# greeting = greet("Олексій")
# print(greeting)  # Виведе: Привіт, Олексій!


# def is_even(num: int) -> bool:
#     return num % 2 == 0

# check_even = is_even(4)
# print(check_even)  # Виведе: True



# def modify_string(original: str) -> str:
#     original = "змінено"
#     return original

# str_var = "оригінал"
# print(modify_string(str_var))  # виведе: змінено
# print(str_var)                # виведе: оригінал


# def modify_list(lst: list) -> None:
#     lst.append(4)

# my_list = [1, 2, 3]
# modify_list(my_list)
# print(my_list)  # виведе: [1, 2, 3, 4]


# def modify_list(lst: list) -> None:
#     lst = lst.copy()
#     lst.append(4)
    

# my_list = [1, 2, 3]
# a = modify_list(my_list) 
# print(a)        # ?????? чому виводить None, а не [1, 2, 3, 4] 
# print(my_list)  # виведе: [1, 2, 3]

# ## ?????? 




# my_list_1 = my_list.copy()
# print(my_list_1)
# my_list_1.append(4)
# print(my_list_1)




# def modify_list(lst: list) -> None:
#     lst = lst.copy()
#     lst.append(4)
#     return lst
    

# my_list = [1, 2, 3]
# a = modify_list(my_list) 
# print(a)        # виводить [1, 2, 3, 4] 
# print(my_list)



# def string_to_codes(string: str) -> dict:
#     # Ініціалізація словника для зберігання кодів
#     codes = {}  
#     # Перебір кожного символу в рядку
#     for ch in string:  
#         # Перевірка, чи символ вже є в словнику
#         if ch not in codes:
#             # Додавання пари символ-код в словник  
#             codes[ch] = ord(ch)  
#     return codes


# result = string_to_codes("Hello world!")
# print(result)



# x = 50

# def func() -> None:
#     x = 2
#     print('Зміна локального x на', x)  # Зміна локального x на 2

# func()
# print('Глобальний x як і раніше', x)  # x як і раніше 50



# def outer_func():
#     enclosing_var = "Я змінна в функції, що охоплює"

#     def inner_func():
#         print("Всередині вкладеної функції:", enclosing_var)

#     inner_func()

# outer_func()



# def func_outer():
#     x = 2

#     def func_inner():
#         nonlocal x
#         x = 5

#     func_inner()
#     return x

# result = func_outer()  # 5
# print(result)



# x = 50

# def func():
#     global x
#     print('x дорівнює', x)  # x дорівнює 50
#     x = 2
#     print('Змінюємо глобальне значення x на', x)  # Змінюємо глобальне значення x на 2

# func()
# print('Значення x складає', x)# Значення x складає 2



# def greet(name, message="Привіт"):
#     print(f"{message}, {name}!")


# # використовує значення за замовчуванням для message
# greet("Олексій")  

# # передача власного значення для message
# greet("Марія", message="Добрий день")  




# def func(a, b=5, c=10):
#     print('a дорівнює', a,', b дорівнює', b,', а c дорівнює', c)

# # a дорівнює 3, b дорівнює 7, а c дорівнює 10
# func(3, 7)

# # a дорівнює 25, b дорівнює 5, а c дорівнює 24
# func(25, c=24)

# # a дорівнює 100, b дорівнює 5, а c дорівнює 50
# func(c=50, a=100)



# def say(message, times=1):
#     print(message * times)

# say('Привіт') 
# say('Світ ', 5)


# def real_cost(base: int, discount: float = 0) -> float:
#     return base * (1 - discount)

# price_bread = 15
# price_butter = 50
# price_sugar = 60

# current_price_bread = real_cost(price_bread)
# current_price_butter = real_cost(price_butter, 0.05)
# current_price_sugar = real_cost(price_sugar, 0.07)

# print(f'Нова вартість хліба: {current_price_bread}')
# print(f'Нова вартість масла: {current_price_butter}')
# print(f'Нова вартість цукру: {current_price_sugar}')



# def print_all_args(*args):
#     for arg in args:
#         print(arg)

# print_all_args(1, 'hello', True)



# def concatenate(*args) -> str:
#     result = ""
#     for arg in args:
#         result += arg
#     return result

# print(concatenate("Hello", " ", "world", "!"))



# def concatenate(*strings) -> str:
#     result = ""
#     for arg in strings:
#         result += arg
#     return result

# print(concatenate("Hello", " ", "world", "!"))



# def greet(**kwargs):
#     for key, value in kwargs.items():
#         print(f"{key}: {value}")

# greet(name="Alice", age=25)



# def example_function(*args, **kwargs):
#     print("Позиційні аргументи:", args)
#     print("Ключові аргументи:", kwargs)

# example_function(1, 2, 3, name="Alice", age=25)

# аналогічний результат дає
# def example_function(*args, **kwargs):
#     print(f"Позиційні аргументи: {args}")
#     print(f"Ключові аргументи: {kwargs}")

# example_function(1, 2, 3, name="Alice", age=25)


# my_list = [1, 2, 3]
# a, b, c = my_list
# print(a)
# print(b)
# print(c)


# b = "pos"

# my_list = [1, 2, 3]
# a, _, c = my_list
# print(a)
# print(b)
# print(c)


# my_list = [1, 2, 3]
# a, *rest = my_list
# print(a)
# print(rest)



# def greet(name, age):
#     print(f"Hello {name}, you are {age} years old.")

# person_info = {"name": "Alice", "age": 25}
# greet(**person_info)


# def factorial(n):
#     if n == 0: # базовий випадок
#         return 1
#     else:
#         return n * factorial(n-1) # рекурсивний випадок

# print(factorial(5)) # виведе 120 = 5! = 5*4*3*2*1



# def fibonacci(n):
#     if n <= 1: # базовий випадок
#         return n
#     else:
#         return fibonacci(n-1) + fibonacci(n-2) # рекурсивний випадок

# print(fibonacci(10)) # виведе 55

# for i in range(1,11):
#     print(fibonacci(i))



# def factorial(n):
#     print("Виклик функції factorial з n = ", n)
#     if n == 1:
#         print("Базовий випадок, n = 1, повернення 1")
#         return 1
#     else:
#         result = n * factorial(n-1)
#         print("Повернення результату для n = ", n, ": ", result)
#         return result

# print(factorial(5))












###### Лекція 2. чт 27.02.2025. Тема 2. Керуючі конструкції, винятки (лектор Сергій Коденко)


# a = 5
# if a > 0:
#     print("a is positive")
# print("fin")


# a = 5
# if a > 0:
#     print("a is positive")  # початок блоку інструкцій - 4 пообіли
# if a < 0:
#     print("a is negative")  # кінець блоку інструкцій
# print("fin")                # поза блоком інструкцій


# a = -5
# if a > 0:
#     print("a is positive")
# else:
#     print("a is negative")


# a = 0
# if a > 0:
#     print("a is positive")
# elif a < 0:
#     print("a is negative")
# else: 
#     print("a is zero")
# print("fin")


# a = -9
# if a > 0:
#     print("a is positive")
# elif a < -10:
#     print("a is less than -10")
# elif a < 0:
#     print("a is negative")
# else: 
#     print("a is zero")
# print("fin")


# # Тернарні оператори

# a = 5
# b = 'positive' if a>0 else 'not positive'
# print('a is', b)


# a = -5
# b = 'positive' if a>0 else 'not positive'
# print('a is', b)

# a = -5
# b = 'positive' if a>0 else ('negative' if a<0 else 'zero') # вкладений тернарний оператор, 
# print('a is', b)                                           # бажано таким не зловживати



# # match - case  - не викоритовує варіантів > або <
# value = 5

# match value:
#     case 5:
#         print('five')
#     case 7:
#         print('seven')
#     case _:
#         print('another value')

# value = 5
# value2 = 5

# match value, value2:
#     case 5, 5:
#         print('five')
#     case 7, value2:
#         print('seven', value2)
#     case value, 10:
#         print('ten')
#     case _:
#         print('another value')


# value = 'del'
# value2 = ''

# match value, value2:
#     case 5, 5:
#         print('five')
#     case 7, value2:
#         print('seven', value2)
#     case value, 10:
#         print('ten')
#     case _:
#         print('another value')


# # AND - і
# # OR - Або
# # NOT - ні
# # XOR - одне з двох, але не два одразу

# a=5
# b=3
# c=4
# r = (a>5) | b ==3  # | знак or
# print(r)

# a=5
# b=3
# c=4
# r = (a>5) or (b ==3)  # | знак or
# print(r)


# a=5
# b=3
# c=4
# r = (a<=5) and (b ==3)  # & знак and
# print(r)

# a=5
# b=3
# c=4
# r = (not a>5) & (b ==3) # & знак and
# print(r)


# a=5
# b=3
# c=4
# r = b<c<a
# print(r)


# a=5
# b=3
# c=4
# r = c>b<a   # c>b and b<a
# print(r)


# r=(True or False) and (True ^ False) # xor це ^
# print(r)

# # Цикли for, while

# # lst = [1,3,5,7,9]
# # for el in lst:
# #     print(el*el)


# # lst = [1,3,5,7,9]   # не змінюємо список, змінючи його елементи перебираючи кожен елемент
# # for el in lst:
# #     el=el*el
# # print(lst)


# # for i in range(len(lst)):     # змінюємо список, змінючи його елементи перебираючи кожен елемент
# #     lst[i] = lst[i]*lst[i]
# #     print(lst[i])
# # print(lst)


# # dictt = {'1': 9, '3': 5, '4': 8, '6': 6}
# # for k in dictt:
# #     print(el)       # перебирає ключі з словника 

# # dictt = {'1': 9, '3': 5, '4': 8, '6': 6}
# # for k in dictt:
# #     dictt[k] = dictt[k] * 2   # змінюємо значення словника
# # print(dictt) 

# # dictt = {'1': 9, '3': 5, '4': 8, '6': 6}
# # for k,v in dictt.items():
# #     print(dictt[k])
# #     print(v)
# #     v*=2
# #     dictt[k]*=2
# # print(dictt) 


# # dictt = {'1': 9, '3': 5, '4': 8, '6': 6}
# # for v in dictt.values():
# #     v*=2
# #     print(v)
# # print(dictt)


# # # цикл while - працює поки виконується якась умова

# # a=5
# # while a>0:
# #     print(a)
# #     a-=1


# # a=5
# # while a>0:
# #     a-=1
# #     print(a)


# # # Введення даних

# # # a = input('Введіть число: ')
# # # if a.isnumeric():
# # #     a = int(a)    
# # print(a)
# # print(type(a))

# # n=None
# # while n is None:                   # поки не введуть в консоль саме число, то буде вимагати ввести число
# #      a = input('Введіть число: ')
# #      if a.isnumeric():
# #          n = int(a)    
# # print(n)
# # print(type(n))


# # a = input('Введіть число: ')
# # if a.isnumeric():
# #      n = int(a)    
# # print(n)
# # print(type(n))


# # n = None
# # a = input('Введіть число: ')
# # if a.isnumeric():
# #      n = int(a)    
# # print(n)
# # print(type(n))


# ## нескінченні цикли while True - для ігор телефонних

# # a=1                  # вручну можемо зупини безкінечний цикл в консолі натиснути Ctrl+C
# # while True:
# #    print(a)
# #    a+=1 
# #    if a>1000: break

# a=1                  
# while True:
#    a+=1
#    if a % 2 == 0: continue  # continue перейти до наступної ітерації, не виконуючи дій під час continue
#    print(a) 
#    if a>1000: break         # break перервати цикл


# # a=1
# # while True:
# #     cmd = input('Enter a command: ')
# #     match cmd:
# #         case 'add':
# #             a+=1
# #         case 'sub':
# #             a-=1
# #         case 'print':
# #             print(a)
# #         case 'exit':
# #             break
# #         case _:
# #             print('unknown command')


# # a=1
# # while True:
# #     cmd = input('Enter a command: ')
# #     match cmd:
# #         case 'add':
# #             a+=1
# #         case 'sub':
# #             a-=1
# #         case 'print':
# #             print('*'*a)
# #         case 'exit':
# #             break
# #         case _:
# #             print('unknown command')
        

# # a=1
# # while True:
# #     inp = input('Enter a command: ')
# #     inp = inp.split()
# #     cmd = inp[0]
# #     inp = inp[1:]
# #     match cmd:
# #         case 'md':  # створити директорію
# #             print(f'Creating dirs {inp}')
# #         case 'cd':
# #             print(f'Changing dir to {inp[0]}')
# #         case 'rm':
# #             print(f'Removing {inp}')
# #         case 'exit':
# #             break
# #         case _:
# #             print('unknown command')



## Обробка помилок


# f=None
# try: 
#    10/0
#    f=open("c\\absent.txt", 'rb') # відкриття файлу якого немає

# except Exception as e:
#     print(type(e))
#     print(f'Error: {e}')

# print('Done')


# f=None
# try: 
#    10/0
#    f=open("c\\absent.txt", 'rb') # відкриття файлу якого немає

# except Exception as e:
#     if isinstance(e, ZeroDivisionError):   
#          print('div by 0')
#          print(f'Error: {e}')
#     elif isinstance(e, FileNotFoundError):
#         print('no file')
#     else:
#         print(f'Error: {e}')

# print('Done')
        


# f=None
# try: 
#    10/0
#    f=open("c\\absent.txt", 'rb') # відкриття файлу якого немає

# except Exception as e:
#     if isinstance(e, ZeroDivisionError):   
#          pass
#     elif isinstance(e, FileNotFoundError):
#         print('no file')
#     else:
#         print(f'Error: {e}')

# print('Done')


# f=None
# try: 
#    #10/0
#    #f=open("c\\absent.txt", 'rb') # відкриття файлу якого немає
#    raise TabError

# except Exception as e:
#     if isinstance(e, ZeroDivisionError):   
#          pass
#     elif isinstance(e, FileNotFoundError):
#         print('no file')
#     else:
#         print(f'Error: {e}')

# print('Done')



# f=None
# try: 
#    #10/0
#    f=open("c\\absent.txt", 'rb') # відкриття файлу якого немає
#    #raise TabError

# except Exception as e:
#     if isinstance(e, FileNotFoundError):
#         print('no file')
#     else:
#         raise e

# finally: 
#     if f is not None # якщо файл був відкрився то закрийте його
#         f.close()    # перервати програму закрити файл

# print('Done')



## Функції 

# def mul2(n):
#     n = n*2
#     return n   

# a=2
# b=4
# print(mul2(a))
# print(mul2(b))
# print(mul2('3'))


# def mul2(m: int) -> int | None: #  -> очікуваний тип значень
#     if isinstance(m, int):
#         n=m
#         if n < 0:
#             n=-n
#         n = n*2
#         return n
#     else:
#         return None
       

# a=-3
# b=4
# print(mul2(a))
# print(mul2(b))
# print(mul2('3'))


# # def findLetter(st: str, letter: str) -> int | None:
# #    counter = 0
# #     for l in st:                        # не вийшло помилка в синтаксисі
# #         if l == letter:
# #             return counter
# #         counter+=1
# #     return None

# # print(findLetter('hello', 'l'))
# # print(findLetter('hello', 'h'))
# # print(findLetter('hello', 'q'))

# # if findLetter('hello', 'l') is not None:
# #     print('found')
# # else:
# #     print('not found')


# def add(a,b):
#     return a+b

# print(add(2,3))


# def add(a,b=1):   # a - позиційний аргумент, b - іменований (ключовий) аргумент
#     return a+b

# print(add(2,3))


# def add(a,b=1, c=3):   # b іменований аргумент
#     return a+b

# print(add(2,c=5, b=4))



# def add(a,*arrgs, b=6):
#     sum = a
#     if len(arrgs)>0:
#         for v in arrgs:
#             sum+=v
#     return sum

# print(add(2,3,4,5,6, b=8))


# def add(a,*arrgs, b=6, **kwargs):
#     sum = a
#     if len(arrgs)>0:
#         for v in arrgs:
#             sum+=v
#             print(args)
#             print(kwargs)
#     return sum

# print(add(2,3,4,5,6, b=8, server = "google.com", port = 1033))


# def add(a,*arrgs, **kwargs):
#     sum = a
#     b = kwargs['b']
#     if len(arrgs)>0:
#         for v in arrgs:
#             sum+=v
#             print(kwargs)
#     return sum

# print(add(2,3,4,5,6, b=8, server = "google.com", port = 1033))

# ## Область видимості

# sum = 10           # G - Global
# def f():
#     sum=20         # E - Ecnlosing близька область видимості
#     def g():
#         sum=30     # L - Local - локальна область видимості
#         print(sum)
#     g()
 
# f()
# print(sum)         # B - Built-int


# # Локальні та глобальні змінні

# def f():
#     x=20
#     return x  # x - local змінна

# f()
# print(x)


# def f():
#     global x  # x - global змінна
#     x=20
#     return x

# f()
# print(x)


# Рекурсія - це коли функція викликає саму себе до якогось моменту

# def fact(n):
#      if n==1: return 1 # якщо n==1 - повертає 1
#      print(n)
#      return n*fact(n-1) 

# print(fact(5))

# # n! = n*(n-1)*(n-2)*...*3*2*1 - факторіал


# # Параметри функції

# def surprise (l=[]):
#     print(l)
#     l.append('X')

# surprise()
# surprise()
# surprise()


# def f():
#     return 'f'
# def g():
#     return 'g'

# def h(x):
#     print(x())

# h(g)
# h(f)





####### ДЗ Тема 2. Автоперевірка

# Завдання 1. Умовне виконання. Оператор if

'''
Створіть програму на Python, яка визначає, чи проходить кандидат в наступний тур співбесіди на основі кількості набраних ним балів у тесті.

Задачі:

Введіть кількість балів, які кандидат набрав у тесті, через функцію input та збережіть їх у змінній num як ціле число.
Використовуйте оператор контролю виконання if-else, щоб визначити, чи проходить кандидат до наступного туру. Якщо num більше або дорівнює 83, змінній is_next привласніть значення True. В іншому випадку привласніть їй значення False.
Очікуваний результат:

Програма повинна отримати кількість балів, набраних кандидатом, та вивести, чи проходить кандидат до наступного туру.

Підказки:

Використовуйте int() для перетворення рядкового введення в ціле число.
Умовний оператор if-else допомагає визначити, яку дію потрібно виконати, залежно від виконання умови.
'''

# is_next = None
# num = int(input("Enter the number of points: "))
# if num >= 83:
#     is_next = True
# else: 
#     is_next = False
# print(is_next)


# Завдання 2. Вираз if-elif-else

'''
Створіть програму на Python, яка визначає категорію розробника (Junior, Middle, Senior) на основі його стажу роботи.

Задачі:

Отримайте від користувача стаж роботи через функцію input та збережіть це значення у змінній work_experience як ціле число.
На основі значення work_experience вам потрібно визначити рівень розробника і зберегти це як рядок у змінній developer_type. Використовуйте наступні правила:
Якщо стаж роботи від 1 року до 5 років включно, developer_type повинен бути "Middle".
Якщо стаж роботи до 1 року включно, developer_type повинен бути "Junior".
Якщо стаж роботи більше 5 років, developer_type повинен бути "Senior".
Очікуваний результат:

Програма має показати рівень розробника в залежності від стажу роботи, який ввів користувач.

Підказки:

Уважно перевірте умови у вашій структурі if-elif-else, щоб вони відповідали правилам визначення рівня розробника.
Не забудьте використати int() для перетворення введеного користувачем рядка у ціле число.
'''
# work_experience = int(input("Enter your full work experience in years: "))

# if 1 < work_experience <= 5 :
#     developer_type = "Middle"
# elif work_experience <= 1:
#     developer_type = "Junior"
# else:
#     developer_type = "Senior"
# print(developer_type)


# Завдання 3. Вкладені вирази if

'''
Напишіть програму на Python, яка визначає характеристику введеного числа: чи воно додатне і парне, додатне і непарне, від'ємне, чи це нуль.

Задачі:

Запросіть користувача ввести ціле число і збережіть його у змінній num.
Використовуйте вкладені умовні вирази для аналізу числа:
Якщо число більше 0, перевірте, чи є воно парним або непарним:
Якщо число парне, залишок від ділення на 2 дорівнює 0, збережіть в змінній result рядок "Positive even number".
Якщо число непарне, залишок від ділення на 2 дорівнює 1, збережіть в змінній result рядок "Positive odd number".
Якщо число менше 0, збережіть в змінній result рядок "Negative number".
Якщо число дорівнює 0, збережіть в змінній result рядок "It is zero".
Очікуваний результат:

В залежності від результату перевірок, програма присвоює змінній result відповідне текстове повідомлення.

Підказки:

Використовуйте оператор залишку від ділення % для перевірки числа на парність.
Зверніть увагу на вірний порядок умовних виразів у вкладеній структурі if-elif-else.
'''

# num = int(input("Enter a number: "))

# if num > 0:
#     if num % 2 != 0: 
#         result = "Positive odd number"
#     else:
#         result = "Positive even number"
# elif num < 0:
#     result = "Negative number"
# else:
#     result = "It is zero"
# print(result)


# Завдання 4. Цикли while

'''
Створіть програму на Python, яка розраховує суму всіх цілих чисел від 1 до числа, введеного користувачем.

Задачі:

Запросіть користувача ввести ціле число від 0 до 100. Збережіть це число в змінній num.
Використовуйте цикл while для підрахунку суми всіх чисел від 1 до введеного числа включно.
Збережіть результат у змінній sum.
Очікуваний результат:

Програма має вирахувати суму всіх чисел від 1 до num включно і зберегти цю суму в змінній sum.

Підказки:

Ініціалізуйте змінну sum значенням 0 перед початком циклу.
В циклі while зменшуйте значення num на 1 після кожного додавання до sum.
Використовуйте цикл while, який продовжується допоки num більше або дорівнює 0.
Тести:

При введеному числі 20, очікувана сума в змінній sum має бути 210.
При введеному числі 10, очікувана сума в змінній sum має бути 55.
При введеному числі 5, очікувана сума в змінній sum має бути 15.
При введеному числі 100, очікувана сума в змінній sum має бути 5050.
'''

# num = int(input("Enter the integer (0 to 100): "))
# sum = 0

# for i in range(1, num+1):
#     sum += i
# print(sum)


# num = int(input("Enter the integer (0 to 100): "))
# sum = 0
# while num >= 0:
#     sum = sum + num
#     num = num - 1
# print (sum)
    

# Завдання 5. Цикли for

'''
Напишіть програму на Python, яка підраховує кількість разів, коли заданий символ зустрічається в рядку.

Задачі:

Використовуючи зазначені змінні message, рядок, у якому буде виконуватися пошук, та search, символ, який ми шукаємо, підрахуйте, скільки разів символ search зустрічається в рядку message.
Для підрахунку використовуйте цикл for, який проходить через кожен символ у message.
Якщо поточний символ збігається з символом у змінній search, збільште змінну result на 1.
Збережіть кінцеву кількість входжень в змінну result.
Очікуваний результат:

Програма має зберегти в змінній result кількість разів, коли символ search зустрічається в рядку message.

Підказки:

Використовуйте == для порівняння поточного символу з символом, який шукаєте.
Пам'ятайте, що цикл for автоматично проходить через кожен символ у рядку.
'''

# message = "Never argue with stupid people, they will drag you down to their level and then beat you with experience."
# search = "r"
# result = 0
# for i in message:
#     if i == search:
#         result = result + 1
# print(result)

# # перевірка
# message.count("r")
 

# Завдання 6. Механізм обробки виключень

'''
Напишіть програму на Python, яка розраховує розмір кожного пакета SMS в кампанії маркетингу, уникаючи помилки поділу на нуль.

Задачі:

Ви маєте змінну pool, яка дорівнює 1000 - кількість SMS, доступних для відправлення.
Запросіть у співробітника маркетингу ввести кількість розсилок quantity.
Обчисліть розмір пакета SMS для кожної розсилки, змінна chunk, поділивши pool на quantity.
Використайте блок try-except для обробки можливої помилки ZeroDivisionError, яка може виникнути, якщо quantity буде дорівнювати 0.
Якщо виникає помилка ZeroDivisionError, виведіть повідомлення про неможливість поділу на нуль.
Очікуваний результат:

Програма має вираховувати розмір пакету SMS для розсилки, або виводити повідомлення про помилку при спробі поділу на нуль.

Підказки:

У блоку try розмістіть код, який може викликати помилку.
У блоку except вкажіть тип помилки, яку ви очікуєте, та дії, які слід виконати у випадку її виникнення.
'''

# pool = 1000
# quantity = int(input("Enter the number of mailings: "))
# try:
#     chunk = pool // quantity  # цілочисельне ділення, бо кількість mailings не може бути дробовою, а тільки цілою
# except ZeroDivisionError:
#     print('Divide by zero completed!')
# else: 
#     print(chunk)


# Завдання 7. Визначення функції

'''
Напишіть програму на Python, яка включає функцію greeting, що виводить вітальне повідомлення, та викличте цю функцію.

Задачі:

Створіть функцію з назвою greeting.
Усередині функції використовуйте команду print для виведення повідомлення "Hello world!".
Після оголошення функції, викличте її, щоб побачити повідомлення на екрані.
Очікуваний результат:

Коли програма виконується, вона має вивести "Hello world!" на екран.

Підказки:

Виклик функції виконується за допомогою її імені та пари круглих дужок.
'''

# def greeting():
#     print("Hello world!")

# greeting()


# Завдання 8. Функція із параметрами

'''
Напишіть програму на Python, яка включає функцію invite_to_event. Ця функція приймає ім'я користувача та повертає персоналізоване запрошення.

Задачі:

Створіть функцію invite_to_event, яка приймає один параметр - username.
Усередині функції використовуйте f-рядок для створення повідомлення з персоналізованим ім'ям.
Функція повинна повертати рядок: "Dear {username}, we have the honour to invite you to our event".
Очікуваний результат:

Функція повертає рядок з персоналізованим запрошенням.

Підказки:

Використовуйте return для повернення результату виклику функції invite_to_event.
Пам'ятайте про використання фігурних дужок {} у f-рядку для вставки значення змінної.
'''

# def invite_to_event(username):
#     return f"Dear {username}, we have the honour to invite you to our event"

# invite_to_event("Oleksandr")



# Завдання 9. Зарезервоване слово "nonlocal"

'''
Необхідно створити функцію discount_price на Python, яка розраховує кінцеву ціну товару після застосування знижки.

Задачі:

Створіть функцію discount_price, яка приймає два аргументи: price - початкова ціна товару та discount - знижка як дійсне число від 0 до 1.
Усередині функції discount_price створіть вкладену функцію apply_discount, яка використовує nonlocal для доступу та модифікації змінної price.
Функція apply_discount має обчислити знижену ціну, помноживши price на (1 - discount).
Викличте apply_discount всередині discount_price, а потім поверніть оновлену ціну.
Очікуваний результат:

Функція повинна повертати ціну товару після застосування знижки.

Підказки:

Використання nonlocal дозволяє функції apply_discount модифікувати змінну price, оголошену у зовнішній функції discount_price.
Для розрахунку зниженої ціни використовуйте формулу price * (1 - discount).
'''

# def discount_price(price, discount):
#     def apply_discount():
#         nonlocal price
#         price = price * (1 - discount)
#     apply_discount()
#     return price
        
# discount_price(100, 0.1)


# Завдання 10. Значення за замовчуванням

'''
Напишіть функцію get_fullname на Python, яка приймає ім'я, прізвище та, опціонально, друге ім'я (або по батькові) та повертає рядок з повним іменем користувача.

Задачі:

Створіть функцію get_fullname, яка приймає три аргументи: first_name, last_name та middle_name. Зробіть middle_name необов'язковим аргументом зі значенням за замовчуванням "".
Якщо middle_name передано, функція повинна повертати повне ім'я у форматі 'first_name middle_name last_name'.
Якщо middle_name не передано, функція повинна повертати повне ім'я у форматі 'first_name last_name'.
Для формування повного імені використовуйте f-рядок.
Очікуваний результат:

Функція повертає рядок з повним іменем користувача, залежно від того, чи передано друге ім'я.

Підказки:

Використовуйте умовну конструкцію if для перевірки, чи middle_name не порожній.
Для створення рядка з повним іменем використовуйте f-рядок для вставки значень змінних.
'''

# def get_fullname(first_name, last_name, middle_name = ''):
#     if middle_name != '':
#         return f'{first_name} {middle_name} {last_name}'
#     else:
#         return f'{first_name} {last_name}'

# def get_fullname(first_name = input('First name: '), last_name = input('Last name: '), middle_name = input('Middle name: ')):
#     if middle_name != '':
#         return f'{first_name} {middle_name} {last_name}'
#     else:
#         return f'{first_name} {last_name}'

# print(get_fullname())

# Завдання 11. Ключові (іменовані) аргументи

# def format_string(string: str, length: int) -> str :
#     if len(string) >= length:
#         return string
#     else:
#         string_print = ' ' * ((length - len(string)) // 2) + string
#         return string_print

# print(format_string('level', 15))

# print(string)


# Завдання 12. Змінна кількість параметрів

'''
Наступне завдання буде суто теоретичним, і ми потренуємося створювати функції в Python, які можуть приймати довільну кількість позиційних або ключових аргументів.

Задачі:

Створіть функцію first, яка приймає один обов'язковий аргумент size та довільну кількість позиційних аргументів. Функція має повертати суму: size + кількість позиційних аргументів.
Створіть функцію second, яка також приймає один обов'язковий аргумент size та довільну кількість ключових аргументів. Функція має повертати суму: size + кількість ключових аргументів.
В обох функціях використовуйте спеціальні синтаксиси * для позиційних аргументів та ** для ключових аргументів.
Очікуваний результат:

Функції повинні коректно розраховувати суму size та кількості переданих аргументів.

Підказки:

*args у функції first означає, що функція може приймати будь-яку кількість позиційних аргументів.
**kwargs у функції second означає, що функція може приймати будь-яку кількість ключових аргументів.
Використовуйте функцію len для визначення кількості позиційних або ключових аргументів.
Приклад коду виконання функцій:

print(first(5, "first", "second", "third"))  # Результат: 8
print(first(1, "Alex", "Boris"))             # Результат: 3
print(second(3, comment_one="first", comment_two="second", comment_third="third"))  # Результат: 6
print(second(10, comment_one="Alex", comment_two="Boris")) # Результат: 12
'''

# def first(size, *args):
#     counter = size + len(args)
#     return counter


# def second(size, **kwargs):
#     counter = size + len(kwargs)
#     return counter

# print(first(5, "first", "second", "third"))  # Результат: 8
# print(first(1, "Alex", "Boris"))             # Результат: 3
# print(second(3, comment_one="first", comment_two="second", comment_third="third"))  # Результат: 6
# print(second(10, comment_one="Alex", comment_two="Boris")) # Результат: 12


# Завдання 13. Рекурсія

'''
Ми проводимо розіграш призів серед перших 50 підписників ютуб-каналу. Ми маємо 7 призів для розіграшу. Може виникнути питання, скільки різних списків переможців ми можемо отримати під час розіграшу? Для цього ми будемо використовувати формулу сполучень без повторень

Cnk = n! / ((n - k)! · k!)

де n — це загальна кількість людей (випадків), а k — кількість людей, які отримали призи.

Напишіть функцію number_of_groups, яка приймає параметри n та k, і за допомогою функції factorial повертає нам скільки різних списків переможців ми можемо отримати при розіграші

Задачі:

Створіть функцію number_of_groups, яка приймає два аргументи: n - загальна кількість людей та k - кількість переможців.
У функції number_of_groups, використовуйте функцію factorial для обчислення факторіалів відповідно до формули сполучень: Cnk = n! / ((n - k)! · k!).
Обчислення здійснюється шляхом виклику функції factorial для отримання факторіалів n, n - k та k.
Поверніть результат цього обчислення.
Очікуваний результат:

Функція number_of_groups повертає кількість можливих різних списків переможців.

Зверніть увагу на те, які великі значення ми отримуємо для факторіала. Рекурсивні висловлювання треба завжди застосовувати з обережністю при обчисленнях, щоб не отримати переповнення пам'яті.
'''

# def factorial(n):
#     if n < 2:
#         return 1
#     else:
#         return n * factorial(n - 1)


# def number_of_groups(n, k):
#     result = factorial(n) // ( factorial(n-k) * factorial(k) )            # n! / ((n - k)! · k!)
#     return result
    
# print(number_of_groups(50, 7))




########### нд 02.03.2025. Практичне заняття 1. Тема 1,2. Лектор (Едуард Літвінчук)

# https://github.com/litvinchukeduard/neoversity-2025-1


