########### Тема 5. Робота з файлами та обробка виключень


'''

Робота з файлами та обробка виключень


Коли застосунок завершує свою роботу, результат його роботи, який зберігався у змінних в застосунку, буде втрачений. Оперативна пам'ять, яка належала застосунку, буде очищена і результат роботи втрачений. Часто нам необхідно зберігати результат роботи, щоб пізніше можна було до нього повернутися. Найпростіший спосіб зберегти корисну інформацію — це записати її у файл на диск. Python надає функціонал роботи з будь-якими файлами.



У Python є абстракція над файлами — це вказівник на файл або файловий об'єкт. Нічого складного в цьому немає, це навпаки спрощує роботу з багатьма системними ресурсами.



Файловий об'єкт — це системний ресурс, доступ до якого надає операційна система. Зазвичай файловий об'єкт можна відкрити (отримати/створити), закрити (повідомити системі, що робота з ним завершена), можна записати у нього щось і прочитати щось.



Безпосередня робота з файлами у Python починається з відкриття файлу або отримання від системи доступу до файлу, отримання того самого файлового об'єкту. Для цього є вбудована функція open, в яку потрібно обов'язково передати ім'я файлу, який ми хочемо відкрити, і можна вказати, як саме ми хочемо відкрити файл:



fh = open('test_file.txt')



В цьому прикладі fh — це файловий об'єкт, через який ми можемо працювати з файлом.



Після того, як робота з файлом завершена, потрібно повернути ресурс (файл) системі. Для цього у файлового об'єкта потрібно викликати метод close:



✂️ Цей код можна запустити! 

fh = open('test.txt')
# операції над файлом
fh.close()



Закривати файл обов'язково. Незакриті файли можуть стати причиною безлічі неочевидних проблем і складнощів. Найпростіший випадок — це зіпсований файл і повністю втрачена інформація, яка в ньому могла міститися.



Крім того, варто пам'ятати, що оскільки файловий об'єкт — це ресурс, який надається операційною системою, то будь-яке завершення роботи застосунку (аварійне або штатне) не означає автоматичне закриття усіх відкритих фалів, що знову ж таки, може призвести до помилок.



Якщо не вказати, як ми хочемо відкрити файл, то він відкривається тільки для зчитування даних і за допомогою fh можна буде тільки читати дані з файлу. Якщо файлу з ім'ям test_file.txt в системі немає, то ви отримаєте виняток.



Після короткого огляду, розглянемо синтаксис функції open() більш детально. Функція open() повертає файловий об'єкт, який далі може бути використаний для читання з файлу або запису в нього.



open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)



Параметри:

file - шлях до файлу у вигляді рядка. Це може бути повний шлях або шлях відносно поточного каталогу виконання.
mode (необов'язковий) - режим, в якому буде відкрито файл. Ось основні режими які ми будемо використовувати:
'r' - читання (за замовчуванням). Файл має існувати.
'w' - запис. Створює новий файл або перезаписує, що вже існує.
'a' - додавання. Дописує в кінець файлу, не перезаписуючи його.
'b' - бінарний режим (може бути використаний разом з іншими, наприклад 'rb' або 'wb').
'+' - оновлення (читання та запис).
buffering (необов'язковий) - визначає буферизацію: 0 для вимкненої, 1 для включеної буферизації рядків, більше 1 для вказання розміру буфера у байтах.
encoding (необов'язковий) - ім'я кодування, яке буде використовуватися для кодування або декодування файлу.
errors (необов'язковий) - вказує, як обробляти помилки кодування.
newline (необов'язковий) - контролює, як обробляються нові рядки.
closefd (необов'язковий) - має бути True (за замовчуванням); якщо вказано False, файловий дескриптор не буде закритий.
opener (необов'язковий) - визначає спеціальну функцію для відкриття файлу.


Насправді нам не потрібні будуть всі параметри, зазвичай нам буде достатньо для використання перших двох.



Наприклад, щоб відкрити файл для запису або створити новий, якщо його немає, або перезаписати файл, можна вказати значення режиму w:



✂️ Цей код можна запустити! 

fh = open('test.txt', 'w')
symbols_written = fh.write('hello!')
print(symbols_written) # 6
fh.close()



В цьому прикладі ми створили (або перезаписали, якщо він вже існував) файл test.txt для запису та записали туди рядок 'hello!' завдовжки 6 символів. Для запису даних у файл ми використали метод write у об'єкта fh. Цей метод повертає кількість записаних у файл символів - в нашому випадку число 6.



Парний до нього метод — це метод read, який дозволяє прочитати деяку кількість символів із файлу.



✂️ Цей код можна запустити! 

fh = open('test.txt', 'w+')
fh.write('hello!')
fh.seek(0)

first_two_symbols = fh.read(2)
print(first_two_symbols)  # 'he'

fh.close()



В цьому прикладі ми відкрили файл в режимі для читання та запису, але сам файл ми перезаписуємо, якщо він існує, бо використовується режим w+. Записали у файл рядок 'hello!' та прочитали перші два символи із файлу за допомогою методу read, вказавши у якості аргументу двійку. Метод read повертає прочитанні символи і оскільки ми прочитали 2 символи, то змінна first_two_symbols буде зберігати рядок "he". Для того, щоб повернути вказівник на початок файлу ми викликали метод seek та передали йому позицію, куди потрібно переміститися 0. Трошки далі ми розглянемо його детальніше.



Щоб прочитати увесь вміст файлу за раз, можна викликати метод read без аргументів:



✂️ Цей код можна запустити! 

fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
all_file = fh.read()
print(all_file)  # 'hello!'

fh.close()



Доки файловий дескриптор не закритий, ви можете читати із нього частинами, продовжуючи читання з того самого місця, на якому зупинилися:



✂️ Цей код можна запустити! 

fh = open('test.txt', 'w')
fh.write('hello!')
fh.close()

fh = open('test.txt', 'r')
while True:
    symbol = fh.read(1)
    if len(symbol) == 0:
        break
    print(symbol)

fh.close()



В цьому прикладі у циклі ми зчитували та виводили у консоль вміст файлу по одному символу за раз. В результаті ви отримаєте у консолі, в стовпчик, всі символи файлу:



h
e
l
l
o
!



Ще є зручний спосіб читати файл порядково, по одному рядку за раз, для цього можна скористатися методом readline:



✂️ Цей код можна запустити! 

fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
while True:
    line = fh.readline()
    if not line:
        break
    print(line)

fh.close()



У циклі while True виконується неперервне читання з файлу. Метод readline() читає один рядок з файлу за раз. Якщо readline() повертає порожній рядок, це означає, що досягнуто кінця файлу, тому цикл переривається за допомогою break. Кожен прочитаний рядок виводиться на екран. Оскільки readline() зберігає символи переходу на новий рядок, кожен виведений рядок буде виведено з нового рядка.



В консолі буде виведення:



first line

second line

third line



Та аналогічний метод readlines, який читає увесь файл повністю, але повертає список рядків, де елемент списку — це один рядок з файлу.



✂️ Цей код можна запустити! 

fh = open('test.txt', 'w')
fh.write('first line\nsecond line\nthird line')
fh.close()

fh = open('test.txt', 'r')
lines = fh.readlines()
print(lines)

fh.close()



Виведення у консолі буде:

['first line\n', 'second line\n', 'third line']



Зверніть увагу, що всі методи, які читають файли порядково, залишають (не видаляють) символ перенесення рядка \n. Його, за необхідності, треба видаляти самостійно:



✂️ Цей код можна запустити! 

fh = open("test.txt", "w")
fh.write("first line\nsecond line\nthird line")
fh.close()

fh = open("test.txt", "r")
lines = [el.strip() for el in fh.readlines()]
print(lines)

fh.close()



Тут ми для видалення символу переносу рядка \n використали метод strip() і тепер виведення в нас чисте:



['first line', 'second line', 'third line']



Тепер повернемось до детального розгляду метода seek. Python дає можливість управляти положенням курсора (вказівника) у файлі та довільно переміщатися файлом за допомогою методу seek. Цей метод приймає один аргумент — це кількість символів, на які потрібно змістити курсор у файлі:



✂️ Цей код можна запустити! 

fh = open('test.txt', 'w+')
fh.write('hello!')

fh.seek(1)
second = fh.read(1)
print(second)  # 'e'

fh.close()



В цьому прикладі після запису у файл курсор буде зупинений на останньому символі. У виразі fh.seek(1) ми перемістили курсор на другий символ у файлі. Переміщаючи курсор, можна перезаписувати символи файлу або читати записане.



Метод seek може приймати опціонально другий аргумент, який буде вказувати, звідки потрібно зчитати зміщення. За замовчуванням зміщення задається від початку файлу, але можна задати з кінця або з поточного положення. На жаль, зазначення зміщення з кінця файлу не на всіх платформах підтримується і краще використовувати варіант за замовчуванням.



Щоб дізнатися положення курсора в цей момент, можна скористатися методом tell, він повертає позицію (номер) символу з початку файлу, де зараз знаходиться курсор.



✂️ Цей код можна запустити! 

fh = open("test.txt", "w+")
fh.write("hello!")

position = fh.tell()
print(position)  # 6

fh.seek(1)
position = fh.tell()
print(position)  # 1

fh.read(2)
position = fh.tell()
print(position)  # 3

fh.close()



Виведення:

6
1
3

Менеджер контексту



Застосунок може виконати багато операцій між відкриттям та закриттям файлу. В будь-якому місці може статися помилка та застосунок завершиться аварійно, не повернувши файловий дескриптор системі. Така поведінка, як вже згадувалося, небажана і може призводити до втрати даних.



Щоб уникнути цього, можна взяти блок коду, в якому відбувається робота з файлом, у блок try ... except:



✂️ Цей код можна запустити! 

fh = open('text.txt', 'w')
try:
    # Виконання операцій з файлом
    fh.write('Some data')
finally:
    # Закриття файлу в блоку finally гарантує, що файл закриється навіть у разі помилки
    fh.close()



Цей підхід гарантує, що файл закриється, але код виглядає трохи загромадженим. Якщо станеться виняток, то обов'язково виконається блок finally, в якому файл буде закритий. Такий підхід гарантує, що файловий дескриптор буде обов'язково повернений системі. Але такий підхід не надто елегантний та читабельний.



☝ Використання конструкції with є кращою практикою, оскільки вона гарантує, що файл буде належним чином закритий після завершення блоку коду.


Для покращення читабельності коду при збереженні функціоналу можна скористатися менеджером контексту with. Менеджер контексту в Python - це спосіб використання ресурсів, який автоматично забезпечує правильне закриття файлу, незалежно від того, чи виникла помилка чи ні. Це робить код не тільки більш читабельним, але й безпечнішим.



with open('text.txt', 'w') as fh:
    # Виконання операцій з файлом
    fh.write('Some data')
# Файл автоматично закриється після виходу з блоку with



Менеджер контексту складається з ключового слова with, після якого викликається сам менеджер і, якщо щось потрібно повернути з менеджера, то це щось можна передати у змінну, оголошену після ключового слова as. Далі ставиться двокрапка і блок коду, який буде виконаний всередині менеджера. У прикладі з try ... finally — це код, який йде всередині блоку try. Коли код виконається, менеджер контексту виконає те, що повинен зробити в будь-якому випадку, закрити файл, наприклад (це те, що відбувається в блоку finally).



Менеджер контексту open синтаксично повністю повторює свого класичного тезку open, вони повністю ідентичні з точки зору використання.



З точки зору роботи, цей приклад робить у точності те саме, що і попередній з блоком try ... finally. Але замість п'яти рядків коду, ви можете написати два, і код виглядає читабельнішим. Тут with автоматично забезпечує закриття файлу, навіть якщо виникає помилка всередині блоку коду. Це робить код не тільки чистішим, але й безпечнішим, оскільки знижує ризик забути закрити файл.



Такий спосіб роботи з файлами є рекомендованим у Python, оскільки гарантує, що програміст не забуде закрити файл у будь-якому разі.



Перепишемо приклад, з попереднього розділу, але вже з менеджером контексту:



✂️ Цей код можна запустити! 

with open("test.txt", "w") as fh:
    fh.write("first line\nsecond line\nthird line")

with open("test.txt", "r") as fh:
    lines = [el.strip() for el in fh.readlines()]

print(lines)



Як бачимо коду стало менше, він чистіше, а виведення залишилось таким самим:



['first line', 'second line', 'third line']



Надалі ми будемо використовувати тільки менеджер контексту при роботі з файлами.

Робота з не текстовими файлами у Python



Поки що ми розглядали тільки роботу з текстовими фалами в кодуванні UTF-8. Це режим роботи з файлами за замовчуванням. Якщо ж потрібно працювати не з текстовими файлами, то можна вказати режим відкриття файлів як b, скорочено від bytes. У такому режимі ви отримаєте файловий об'єкт для роботи з файлом в режимі байт-рядків.



✂️ Цей код можна запустити! 

with open('raw_data.bin', 'wb') as fh:
    fh.write(b'Hello world!')



В цьому прикладі ми відкрили файл raw_data.bin у режимі для запису "сирих" даних, на що вказує значення wb. В цьому режимі у файл можна писати тільки байт-рядки або байт-масиви.



У режимі роботи з "сирими" даними можна відкрити та прочитати вміст будь-якого файлу. Замість терміну “сирі” дані, можуть також казати двійкові дані або бінарні дані.



Отже є ще один контейнер, з яким ми раніше не працювали. Це bytes — байтові рядки.



Байтові рядки в Python є важливим інструментом для роботи з двійковими даними. Вони дозволяють зберігати та обробляти байти, які є основними будівельними блоками даних у комп'ютерах.



У пам'яті комп'ютера дані зберігаються як послідовності байтів. Будь-яка інформація - текст, зображення, звук, тощо - може бути представлена у вигляді байтів. Відповідно, будь-які дані можна представити у вигляді послідовності байтів.



Щоб працювати з послідовністю байтів у Python є вбудовані типи даних байт-рядків



bytes - незмінний тип, що використовують для представлення байтів.
bytearray - змінний тип, що дозволяє модифікувати байти після їх створення.


Застосування байтових даних досить поширене. Наприклад байтові рядки важливі для роботи з мережевими протоколами (наприклад, TCP/IP), послідовними портами, telnet та іншими протоколами, де дані передаються як потік байтів.



За своєю суттю байт-рядки або простіше байти — це звичайні рядки, але для запису одного символу використовується суворо один байт. Це відрізняється від звичайних рядків, де символи (особливо в Unicode) можуть займати більше одного байта.



Але що таке байт та біт насправді для комп'ютера? Розглянемо це більше детально.



Біт (скорочено від "binary digit" або "двійкова цифра") є основною одиницею інформації в обчислювальній техніці та цифровій комунікації. Біт може мати одне з двох значень: 0 або 1. Ви можете думати про біт, як про відповідь на просте питання: "так/ні" або "вимкнено/увімкнено".



Байт - це послідовність з 8 бітів, яка є стандартною одиницею вимірювання кількості інформації в комп'ютерах. Один байт може представляти 256 різних станів. Від 00000000 до 11111111 у двійковому форматі або від 0 до 255 десятеричному, що дозволяє кодувати широкий спектр інформації, наприклад, символи тексту, частини зображень або звуку.



У комп'ютерах кожен символ у тексті (наприклад, літера або цифра) зазвичай кодується одним байтом. Наприклад, у кодуванні ASCII символ 'A' представляється як 01000001. Усі дані на комп'ютері зберігаються у вигляді байтів. Наприклад, текстовий файл розміром у 1 кілобайт займає 1024 байти в пам'яті комп'ютера. Коли дані передаються через інтернет мережу, вони також розбиваються на байти.



Звісно не всі програмісти працюють напряму з бітами та байтами, але розуміти це потрібно. Оскільки біти та байти є фундаментом всіх цифрових систем. Вони дозволяють комп'ютерам представляти та обробляти всі види інформації, від простих документів до складних відео та звуків.



Для байт-рядків застосовуються ті самі обмеження і правила, що і для звичайних рядків. Наприклад, ви можете використовувати методи upper(), startswith(), index(), find() і так далі.



Індексація працює так само, як і в звичайних рядках:



✂️ Цей код можна запустити! 

s = b'Hello!'
print(s[1])  # Виведе: 101 (це ASCII-код символу 'e')



Але повертає число, в нашому прикладі 101. Це ASCII-код символу 'e'.



ASCII (American Standard Code for Information Interchange - Американський стандартний код для обміну інформацією) - це символьна кодова таблиця, яка використовується для представлення тексту в комп'ютерах, комунікаційному обладнанні та інших пристроях, що працюють з текстом. Кожен символ у таблиці ASCII відповідає певному числу.



ASCII визначає 128 символів, що включають латинські літери, цифри, знаки пунктуації, а також символи управління. Кожен символ кодується 7-бітним числом, що дозволяє представити числа від 0 до 127. Існує також розширений ASCII, який використовує 8-бітне кодування для представлення 256 символів (від 0 до 255). Це розширення включає додаткові символи, такі як латинські літери з діакритичними знаками, графічні символи тощо.



Наведемо приклади ASCII-кодів



Цифри: '0' - 48, '1' - 49, ..., '9' - 57.
Великі латинські літери: 'A' - 65, 'B' - 66, ..., 'Z' - 90.
Малі латинські літери: 'a' - 97, 'b' - 98, ..., 'z' - 122.
Спеціальні символи: пробіл - 32, '!' - 33, '@' - 64 тощо.


ASCII широко використовується для зберігання та обробки тексту в комп'ютерах, особливо для англомовного контенту. Мережеві протоколи та комунікаційні інтерфейси часто використовують ASCII для передачі текстової інформації. Але ASCII не підтримує символи багатьох мов, що не використовують латинський алфавіт. Через це були розроблені інші формати кодування, такі як UTF-8, які підтримують широкий спектр мовних символів та інших знаків. Про нього ми розповімо окремо трохи далі.



ASCII важливий стандарт у ранньому розвитку комп'ютерних технологій, який заклав основу для подальшої розробки систем кодування тексту. Хоча зараз він частково замінений більш універсальними системами кодування, такими як UTF-8, ASCII все ще має значення у багатьох областях обчислювальної техніки.



Створимо наступний байт-рядок:



byte_string = b'Hello world!'



В цьому прикладі у byte_string містить послідовність символів по одному байту на кожного. Від оголошення звичайного рядку байт-рядок вирізняє наявність символу b на початку рядка.



Другий спосіб створення байт рядків — це перетворення у байт-рядок.



Для перетворення рядка у байт-рядок можна скористатися методом рядків encode. Коли ви використовуєте .encode(), ви перетворюєте рядок у байтову послідовність. Метод .encode() важливий, оскільки він дозволяє стандартизувати рядок для операцій, які вимагають однакового представлення символів, незалежно від системи або платформи.



✂️ Цей код можна запустити! 

byte_str = 'some text'.encode()
print(byte_str)



У byte_str буде записана послідовність байтів b'some text'.



Синтаксис:



str.encode(encoding="utf-8", errors="strict")



encoding - вказує метод кодування. По замовчуванню використовується 'utf-8', який підтримує велику кількість символів з різних мов.
errors - вказує, як обробляти помилки кодування. Наприклад, 'strict' для викидання виключення у випадку помилки, 'ignore' для ігнорування помилок або 'replace' для заміни неможливих для кодування символів на певний замінник (?).


Ви повинні зрозуміти, що метод .encode() є фундаментальним для роботи з текстовими даними в Python, оскільки він забезпечує зв'язок (місток) між текстом (рядками Unicode) та байтами, які можуть бути використані в бінарних операціях або в передачі даних по мережі.





Перетворення чисел у байт-рядки

У Python ви можете перетворювати числа у байт-рядки за допомогою вбудованої функції bytes. Це корисно для роботи з двійковими даними, особливо коли потрібно зберігати або передавати числові значення у форматі, оптимізованому для обробки на низькому рівні.



В один байт поміщається число від 0 до 255 включно, відповідно можна перетворити послідовність чисел від 0 до 255 у байт-рядок за допомогою функції bytes:



✂️ Цей код можна запустити! 

# Перетворення списку чисел у байт-рядок
numbers = [0, 128, 255]
byte_numbers = bytes(numbers)
print(byte_numbers)  # Виведе байтове представлення чисел



В цьому прикладі, числа від 0 до 255 перетворюються на відповідні байти. Оскільки кожне число у діапазоні від 0 до 255 займає рівно один байт, вони безпосередньо перетворюються в байтовий рядок. Для виведення байтів найзручніше скористатися шістнадцятковим записом, в якому для запису чисел від 0 до 255 достатньо двох символів. Саме такий запис використовує Python "за замовчуванням" для байтів.



Виведення:



b'\x00\x80\xff'



Тут використовується шістнадцятковий формат для зручного відображення байтів. Символ \x є індикатором шістнадцяткового запису кожного байта.



Щоб перевірити правильність представлення, можна скористатися вбудованою функцією hex, яка перетворить ціле число в рядок — представлення числа в шістнадцятковій формі:



✂️ Цей код можна запустити! 

for num in [127, 255, 156]:
  print(hex(num))



Цей код демонструє, як перетворити числа у їх шістнадцяткові рядкові представлення, починаючи з 0x, що вказує на шістнадцяткову форму запису. В результаті виконання ви побачите:



0x7f
0xff
0x9c



В такому вигляді перші два символи 0x вказують на шістнадцяткову форму запису .



Такий механізм корисний у різноманітних сценаріях, включаючи низькорівневе програмування, роботу з мережевими протоколами та обробку бінарних файлів. Він дозволяє працювати з байтами більш інтуїтивно, надаючи змогу легко перевірити та візуалізувати бінарні дані.





Кодування рядків (ASCII, UTF-8, CP1251)

Перші комп'ютери для роботи з текстом використовували так зване ASCII кодування. У цьому кодуванні для запису одного символу використовується один байт.



Зручність цього кодування в тому, що будь-які дані на комп'ютері можна спробувати представити у вигляді тексту в цьому кодуванні. ASCII містить 256 символів. Це не дуже багато і деякий час цього було достатньо. Але з часом алфавіту з 256 символів стало мало, виникла необхідність додати все більше символів (кирилиця, діакритичні знаки, коди валют, ієрогліфи тощо). Щоб задовольнити потребу у додаванні нових символів, придумали використати кодування, де більше одного байту на символ. Python за замовчуванням використовує UTF-8, в якій один символ може займати від 1 до 4 байт, і всього в алфавіті може бути до 1 112 064 знаків. Це не єдине кодування, на різних платформах можуть бути присутні власні, наприклад CP-1251 (кирилиця на ОС сімейства Windows), UTF-16, UTF-32 та інші.



Щоб дізнатися, якому елементу в UTF-8 відповідає символ, є функція ord (від order).



Наприклад, символ 'a' кодується числом 97:



ord('a')  # 97



Зворотна операція, коли потрібно дізнатися, який символ закодований числом, наприклад 100, є функція chr (скорочено від character):



chr(128)  # 'd'



Python може працювати з дуже великою кількістю різних кодувань.



✂️ Цей код можна запустити! 

s = "Привіт!"

utf8 = s.encode()
print(f"UTF-8: {utf8}")

utf16 = s.encode("utf-16")
print(f"UTF-16: {utf16}")

cp1251 = s.encode("cp1251")
print(f"CP-1251: {cp1251}")

s_from_utf16 = utf16.decode("utf-16")
print(s_from_utf16 == s)



Виведення:

UTF-8: b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd1\x96\xd1\x82!'
UTF-16: b'\xff\xfe\x1f\x04@\x048\x042\x04V\x04B\x04!\x00'
CP-1251: b'\xcf\xf0\xe8\xe2\xb3\xf2!'
True



Спроба перетворити байт-рядок в неправильному кодуванні, призводить або до помилки, або до досить непередбачуваного результату:



✂️ Цей код можна запустити! 

print(b'Hello world!'.decode('utf-16'))



Виведення якщо кодування UTF-8 ми намагаємось декодувати в UTF-16:

效汬⁯潷汲Ⅴ



А тепер до важливого, навіщо нам знати про інші стандарт, якщо зараз все в UTF-8. При роботі з файлами в операційній системі Windows часто виникає проблема, пов'язана зі стандартним кодуванням. Windows за замовчуванням використовує кодування CP-1251 (також відоме як Windows-1251), яке є стандартним для багатьох країн, де використовується кирилиця. Це кодування істотно відрізняється від UTF-8, яке є універсальним і підтримує широкий спектр символів з різних мов. А нагадаємо, що стандарт зараз всюди це саме UTF-8.



Коли файл зберігається в кодуванні, відмінному від UTF-8, і потім відкривається у програмі, яка очікує UTF-8 (або навпаки), це може призвести до неправильного відображення тексту. Символи, які не відповідають стандарту кодування, можуть відображатися як нерозпізнані знаки або викликати помилки при читанні файлу.



Щоб уникнути проблем з кодуванням, особливо при роботі з міжнародними текстами або в середовищах з різними налаштуваннями кодування, рекомендується завжди явно вказувати кодування UTF-8 під час відкриття файлів у Python. Це можна зробити за допомогою параметра encoding у функції open().



✂️ Цей код можна запустити! 

# Відкриття текстового файлу з явним вказівкам UTF-8 кодування
with open('example.txt', 'r', encoding='utf-8') as file:
    content = file.read()
    print(content)



У цьому прикладі, навіть якщо операційна система використовує інше кодування за замовчуванням, файл буде коректно відкритий із використанням UTF-8, що гарантує правильне відображення тексту.



У світі, де дані часто обмінюються між різними системами та платформами, уніфікація кодування до UTF-8 є ключовим фактором для забезпечення сумісності та коректності обробки текстових даних. Вказання кодування при відкритті файлів функцією open() допомагає уникнути багатьох проблем, пов'язаних з локалізацією та міжнародною підтримкою.





Масив байтів

Робота з рядками обмежена тим, що рядки і байт-рядки незмінні. Якщо потрібно замінити навіть один символ, потрібно, по суті, створити копію початкового рядка з єдиним відмінним символом. Щоб зменшити накладні витрати при роботі з "сирими" даними, в Python є такий контейнер як bytearray.



✂️ Цей код можна запустити! 

byte_array = bytearray(b'Kill Bill')
byte_array[0] = ord('B')
byte_array[5] = ord('K')
print(byte_array)



Виведення:

bytearray(b'Bill Kill')



Основна відмінність від байт-рядків — це змінність, щоб змінити масив байтів, не потрібно створювати новий. Друга важлива відмінність — це те, що масив байтів сприймається системою як послідовність чисел від 0 до 255, а не як послідовність символів в ASCII кодуванні. Саме тому не можна написати byte_array[0] = b'B'. Елементи масиву байтів сприймаються саме як цілі числа.



В іншому ж bytearray може використовуватися як заміна байт-рядків і у нього є ті самі методи з тією самою поведінкою.



Окрім зміни існуючих елементів, bytearray дозволяє додавати та видаляти елементи, що робить його набагато більш гнучким у порівнянні з незмінними байт-рядками.



✂️ Цей код можна запустити! 

byte_array = bytearray(b"Hello")
byte_array.append(ord("!"))  
print(byte_array)



Виведення:

bytearray(b'Hello!')



Хоча bytearray сприймається як послідовність чисел, його можна легко перетворити в рядок за допомогою методу decode(), вказавши потрібне кодування.



✂️ Цей код можна запустити! 

byte_array = bytearray(b"Hello World")
string = byte_array.decode("utf-8")
print(string)  # Виведе: 'Hello World'



Виведення:

Hello World



bytearray особливо корисний при обробці бінарних даних, наприклад, при читанні файлів у бінарному режимі, обробці мережевих пакетів, або при роботі з образами даних у пам'яті.





Порівняння рядків

Принцип порівняння рядків, з перетворенням їх у єдиний регістр, використовується для забезпечення нерозрізнення регістру при порівнянні. Це особливо корисно, коли порівняння повинно бути незалежним від того, чи введено рядок у верхньому, нижньому чи змішаному регістрі.



Основні кроки процесу порівняння наступні.



Перше, це перетворення рядків у єдиний регістр. Це може бути або перетворення всіх символів рядка у нижній регістр за допомогою методу .lower(), або у верхній регістр за допомогою .upper().



Далі сама операція порівняння рядків. Після перетворення обох рядків у однаковий регістр, вони порівнюються. Якщо рядки однакові після перетворення, вони вважаються еквівалентними у контексті нерозрізнення регістру.



✂️ Цей код можна запустити! 

string1 = "Hello World"
string2 = "hello world"
if string1.lower() == string2.lower():
    print("Рядки однакові")
else:
    print("Рядки різні")



Виведення:

Рядки однакові



Коли використовують саме таку техніку порівняння рядків? При пошуку або фільтрації даних, де важливо ігнорувати різницю у регістрі наприклад, пошук користувача за ім'ям в базі даних. У веб-застосунках, для забезпечення консистентного порівняння введених даних наприклад, при вході в систему або пошуку на сайті.



Але порівняння рядків у Python може давати неоднозначний результат внаслідок того, що в UTF-8 кодуванні один і той самий символ можна представити декількома кодами, наприклад, символ 'ê' можна представити кодом U+00EA, або як послідовність двох кодів U+0065 та U+0302. З цієї причини порівняння одного і того самого символу може повернути False через відмінності у записі.



Щоб розв'язати цю проблему при роботі з не ASCII символами для порівняння рядків, їх необхідно нормалізувати за допомогою методу casefold, який повертає рядок, де всі символи у нижньому регістрі і без неоднозначностей, коли будь-який символ матиме тільки одну можливу форму запису.



Цей метод схожий на lower(), але casefold() є більш радикальним: він призначений для видалення усіх відмінностей у регістрі, які можуть виникати в різних мовах, і тому є більш ефективним для випадків, де потрібно забезпечити нерозрізнення регістру в різноманітних мовах.



text = "Python Programming"
print(text.casefold())



Виведення буде 'python programming' таке саме як і для методу .lower().



Але головне застосування casefold() для мов, де одна літера може мати різні верхній та нижній регістри, наприклад, в німецькій мові.



У німецькій мові, літера "ß" (так званий "sharp S" або "eszett") використовується для позначення специфічного звука, що наближений до подвоєного "ss". Ця літера не має прямого еквіваленту у верхньому регістрі. Традиційно, коли слово, що містить "ß", потрібно написати великими літерами, "ß" перетворюється на "SS".



Ось тут casefold() виявляється корисним:



✂️ Цей код можна запустити! 

german_word = 'straße'  # В нижньому регістрі
search_word = 'STRASSE'  # В верхньому регістрі

# Порівняння за допомогою lower()
lower_comparison = german_word.lower() == search_word.lower()

# Порівняння за допомогою casefold()
casefold_comparison = german_word.casefold() == search_word.casefold()

print(f"Порівняння з lower(): {lower_comparison}")
print(f"Порівняння з casefold(): {casefold_comparison}")



У цьому прикладі, casefold() правильно вважатиме, що рядки "straße" та "STRASSE" еквівалентні, оскільки він враховує особливе перетворення "ß" в "ss". Це може бути важливо у сценаріях, де необхідно забезпечити точне порівняння тексту незалежно від регістру, наприклад, при пошуку у базі даних або при введенні даних користувачем.



Виведення:



Порівняння з lower(): False
Порівняння з casefold(): True



Цей випадок показує, що casefold() є більш ефективним для мов, які мають особливі правила перетворення символів у різних регістрах. У більшості життєвих сценаріїв, особливо при роботі з англійським текстом, lower() і casefold() будуть працювати подібно, але casefold() надає додаткову точність для специфічних мовних випадків.

Робота з архівами



Архіви по своїй суті — це ті самі файли, але інформація в них розташована з використанням алгоритмів стискання, які дозволяють записати інформацію в меншому об'ємі.



Ви можете відкрити будь-який архів як файл в режимі роботи з байт-рядками, реалізувати алгоритм стискання і розпаковування на Python, і отримати власний архіватор/деархіватор. Ця досить цікава вправа і ви, звичайно, можете її виконати, якщо хочете глибше розібратися в алгоритмах стискання.



Одна з головних причин популярності Python — в наявності великої кількості пакетів та модулів зі всіляким функціоналом, які можна використати для своїх потреб. Є простіший спосіб роботи з популярними безкоштовними архівами у Python — це пакет shutil, який представляє просунутіший файловий менеджер та вміє працювати з архівами.



☝ Модуль shutil в Python - це модуль стандартної бібліотеки, який надає ряд функцій для роботи з файлами і колекціями файлів. Цей модуль може бути використаний для копіювання, переміщення, перейменування та видалення файлів і директорій, забезпечуючи високорівневі операції для обробки файлової системи, які є більш зручними, ніж використання базових функцій модуля os.


Пакет shutil підтримує архіви zip, tar, gz. Для цього він використовує пакети zipfile та tarfile. Ви можете використовувати їх напряму, якщо захочете.



Функція shutil.make_archive() в Python використовується для створення архівів (наприклад, ZIP або TAR файлів) з заданої директорії. Ця функція є частиною модуля shutil, який надає багато зручних операцій для роботи з файлами, включаючи копіювання та архівування.



Синтаксис методу:

shutil.make_archive(base_name, format, root_dir=None, base_dir=None)



Параметри:

base_name - шлях до файлу, де потрібно зберегти архів, без розширення.
format - формат архіву, наприклад 'zip', 'tar', 'gztar', 'bztar' або 'xztar'.
root_dir - директорія, з якої буде створено архів. Якщо не вказано, використовується поточна директорія.
base_dir - директорія всередині архіву, з якої почнеться архівація.




Створення zip архіву.

import shutil

# Створення ZIP-архіву з вмістом директорії 'my_folder'
shutil.make_archive('example', 'zip', root_dir='my_folder')



Цей код створить zip архів з ім'ям example.zip, що містить усі файли та піддиректорії, що знаходяться у директорії my_folder.





Створення gztar архіву.

import shutil

# Створення TAR.GZ архіву
shutil.make_archive('example', 'gztar', root_dir='my_folder')



У цьому випадку створюється TAR-архів з GZIP-стисненням.



Навіщо нам потрібно архівування? Це автоматизація процесу створення резервних копій файлів та директорій. Створення архівів з програмним кодом, ресурсами або документацією для подальшого розповсюдження. Архівування для зменшення обсягу використовуваного дискового простору або для спрощення передачі файлів через мережу.



Звичайно пакет shutil підтримує розпаковування архівів. Функція shutil.unpack_archive() використовується для розпакування архівних файлів, таких як ZIP або TAR, до вказаної директорії. Це зручний спосіб автоматизувати процес розпакування без необхідності вручну використовувати інструменти архівування.



Синтаксис

shutil.unpack_archive(filename, extract_dir=None, format=None)



Параметри

filename - шлях до архівного файлу, який потрібно розпакувати.
extract_dir - директорія, куди буде розпаковано вміст архіву. Якщо не вказано, використовується поточна директорія.
format - формат архіву наприклад, zip, tar, gztar, bztar, або xztar. Якщо параметр не вказано, Python намагається визначити формат автоматично.




Розпакування zip архіву:

import shutil

# Розпакування ZIP-архіву в певну директорію
shutil.unpack_archive('example.zip', 'destination_folder')



Цей код розпакує вміст example.zip у директорію destination_folder.



Окрім роботи з архівами модуль shutil може ще виконувати наступні високорівневі операції для обробки файлової системи:



shutil.copy(src, dst) копіює файл з src в dst. Якщо dst є директорією, файл буде скопійований зі своїм поточним іменем у цю директорію.
shutil.copytree(src, dst) рекурсивно копіює всю директорію src в директорію dst.
shutil.move(src, dst) переміщує файл або директорію src в dst.
shutil.rmtree(path) рекурсивно видаляє директорію path.
shutil.disk_usage(path) повертає статистику використання диска, що містить загальний об'єм, використаний об'єм і вільний об'єм для даного шляху.


Наведемо приклад використання shutil для копіювання файлу та директорії:



import shutil

# Копіюємо файл
source_file = '/path/to/source/file.txt'
destination_dir = '/path/to/destination'
shutil.copy(source_file, destination_dir)

# Копіюємо всю директорію
source_dir = '/path/to/source/directory'
destination_dir = '/path/to/destination/directory'
shutil.copytree(source_dir, destination_dir)



Важливо зазначити, що перед використанням функцій, які модифікують файлову систему, слід з особливою увагою перевіряти шляхи та параметри, щоб уникнути втрати даних. За це відповідає модуль pathlib який ми розглянемо далі.

Основи модуля pathlib



Модуль pathlib в Python є сучасним інструментом для роботи з файловою системою, що надає об'єктно-орієнтований інтерфейс для роботи з шляхами. Він прийшов на заміну застарілому модулю os, роботу з яким ще можна зустріти в старих прикладах коду.



pathlib - це модуль у Python, який надає класи для обробки файлових шляхів у об'єктно-орієнтованому стилі. Два основних класи у цьому модулі - це Path та PurePath.



PurePath - це базовий клас у pathlib, який надає об'єктно-орієнтовані методи для маніпуляції шляхами без доступу до файлової системи. Він може бути використаний для роботи з шляхами на різних операційних системах. PurePath дозволяє виконувати такі операції, як розділення шляху на частини, перевірка суфіксів, імен файлів, шляхів тощо.



✂️ Цей код можна запустити! 

from pathlib import PurePath

p = PurePath("/usr/bin/simple.jpg")
print("Name:", p.name)  
print("Suffix:", p.suffix) 
print("Parent:", p.parent)



Виведення:



Name: simple.jpg
Suffix: .jpg
Parent: \usr\bin



У PurePath є ряд корисних методів та атрибутів:



p.parent вказує на батьківську директорію;
p.name повертає лише рядок з ім'ям директорі або файлу, на який вказує p;
p.suffix повертає рядком розширення файлу, на який вказує p, починаючи з крапки;


Клас Path наслідує всі методи з PurePath і додає методи для виконання операцій, які вимагають доступу до файлової системи, таких як читання, запис файлів, перевірка існування файлів тощо. З класом Path можна створювати нові файли, читати та записувати дані, перевіряти існування шляхів, перелічувати файли у директорії тощо.



В основному робота з файловою системою ведеться через Path. Path варто сприймати як вказівку на файл або директорію. Щоб створити такий Path, достатньо викликати Path як функцію та передати у якості аргументу рядок-адресу у файловій системі:



✂️ Цей код можна запустити! 

from pathlib import Path

p = Path("example.txt")
p.write_text("Hello, world!")
print(p.read_text()) 
print("Exists:", p.exists()) 



Виведення:

Hello, world!
Exists: True



У даному фрагменті коду використовується модуль pathlib для створення, запису, читання та перевірки файлу. Спочатку створюється об'єкт Path, який вказує на файл example.txt у директорії де був запущений скрипт. За допомогою методу write_text(), у цей файл записується рядок "Hello, world!". Потім за допомогою методу read_text() вміст файлу читається і виводиться на екран. На завершення, метод exists() використовується для перевірки існування файлу, результат чого також виводиться на екран. Весь код демонструє просту інтеракцію з файловою системою через об'єктно-орієнтований інтерфейс pathlib.



Застосування Path і PurePath залежить від конкретних потреб програми. Для більшості практичних цілей Path буде найкращим вибором, оскільки він надає більш широкий спектр можливостей для роботи з файлами та директоріями.





Створення Шляхів

Створення шляхів за допомогою класу Path у модулі pathlib у Python є зручним способом маніпуляції файловими шляхами, який абстрагує від особливостей конкретної операційної системи.



Клас Path автоматично адаптується до особливостей шляхів у різних операційних системах. Наприклад, у Windows використовуються зворотні слеші (\), тоді як в Unix-подібних системах (Linux, macOS) - прямі слеші (/).



Сам приклад процесу створення шляху наступний:



from pathlib import Path

# Для Unix/Linux
path_unix = Path("/usr/bin/python3")

# Для Windows
path_windows = Path("C:/Users/Username/Documents/file.txt")



Об'єднання шляхів у pathlib - це процес, за допомогою якого можна створювати повні шляхи до файлів або директорій шляхом додавання різних частин шляху разом.



Для об'єднання шляхів використовується оператор /. Це інтуїтивний спосіб створення шляху, який абстрагується від різниці в синтаксисі шляхів між різними операційними системами.



Розглянемо приклад:



✂️ Цей код можна запустити! 

from pathlib import Path

# Початковий шлях
base_path = Path("/usr/bin")

# Додавання додаткових частин до шляху
full_path = base_path / "subdir" / "script.py"

print(full_path)  # Виведе: /usr/bin/subdir/script.py



У цьому прикладі, до початкового шляху base_path додаються додаткові частини - директорія "subdir" та файл "script.py". Оператор / дозволяє це зробити чисто та зрозуміло і ми отримуємо шлях до файлу:



\usr\bin\subdir\script.py





Відносні та абсолютні шляхи

При роботі з файлами та директоріями у Python важливо розуміти відмінності між відносними та абсолютними шляхами. Модуль pathlib надає інструменти для роботи з обома типами шляхів.



Абсолютний шлях - це повний шлях до файлу або директорії від кореня файлової системи. Він містить всю інформацію, необхідну для знаходження файлу або директорії.



Приклад на Unix/Linux: /home/user/documents/example.txt
Приклад на Windows: C:\Users\user\documents\example.txt



Абсолютні шляхи використовують, коли потрібно точно вказати місцезнаходження файлу або директорії, незалежно від поточного робочого каталогу програми.



Відносний шлях - це шлях до файлу або директорії відносно поточного робочого каталогу. Він не містить повну інформацію про місцезнаходження і залежить від місця, з якого виконується програма.

Припустимо, ви працюєте на комп'ютері з Windows, і ваш поточний робочий каталог (там, де ви виконуєте ваш Python скрипт) - наприклад це C:\Users\Username. Ваша задача - працювати з файлом example.txt, який знаходиться у підкаталозі Documents вашого домашнього каталогу.



Абсолютний шлях в Windows включає літеру диска і вказує повний шлях до файлу від кореня диска. Наприклад, абсолютний шлях до нашого файлу може виглядати як C:\Users\Username\Documents\example.txt.



Відносний шлях визначається відносно поточного робочого каталогу. Якщо ваш поточний робочий каталог - C:\Users\Username, то відносний шлях до файлу example.txt у директорії Documents буде просто Documents\example.txt.



З pathlib, ви можете легко перетворювати шляхи між абсолютними та відносними форматами.



✂️ Цей код можна запустити! 

from pathlib import Path

# Перетворення відносного шляху в абсолютний
relative_path = Path("documents/example.txt")
absolute_path = relative_path.absolute()
print(absolute_path)



Розглянемо приклад, який було запущено в директорії (поточний робочий каталог) автора курсу. Зазначимо, що у вас директорія може бути інша:



E:\WebDir\Works\Python\python-help-solution\example_for_new_core\l04



Тоді, при виконанні прикладу ми повинні отримати наступне виведення:



E:\WebDir\Works\Python\python-help-solution\example_for_new_core\l04\documents\example.txt



У цьому прикладі, Path("documents/example.txt") створює відносний шлях. Метод absolute() перетворює його в абсолютний шлях, виходячи з поточного робочого каталогу.



Існує метод relative_to() який навпаки, використовується для отримання відносного шляху відносно заданої директорії.



✂️ Цей код можна запустити! 

from pathlib import Path

# Перетворення відносного шляху в абсолютний
relative_path = Path("documents/example.txt")
absolute_path = relative_path.absolute()

current_working_directory = Path("E:\WebDir\Works\Python\python-help-solution\example_for_new_core\l04")
relative_path = absolute_path.relative_to(current_working_directory)
print(relative_path)



Розуміння та використання абсолютних та відносних шляхів важливе при написанні програм, які читають, записують або маніпулюють файлами та директоріями.





Маніпуляція з компонентами шляху

Клас Path надає зручні методи для маніпулювання компонентами шляху, такі як with_name і with_suffix. Ці методи дозволяють легко змінювати ім'я файлу або його розширення в об'єкті Path.



Метод with_name замінює ім'я файлу в шляху на нове. Він корисний, коли вам потрібно змінити тільки ім'я файлу, зберігаючи решту шляху незмінною.



✂️ Цей код можна запустити! 

from pathlib import Path

# Початковий шлях до файлу
original_path = Path("documents/example.txt")

# Зміна імені файлу
new_path = original_path.with_name("report.txt")
print(new_path)



У цьому прикладі, with_name("report.txt") замінює ім'я файлу example.txt на report.txt, при цьому зберігаючи решту шляху documents без змін.



documents\report.txt



Метод with_suffix замінює або додає розширення файлу в шляху. Це корисно, коли потрібно змінити тип файлу або додати розширення до файлу, який його не має.



✂️ Цей код можна запустити! 

from pathlib import Path

# Початковий шлях до файлу
original_path = Path("documents/example.txt")

# Зміна імені файлу
new_path = original_path.with_suffix(".md")
print(new_path)



У цьому прикладі, метод with_suffix(".md") додає розширення .md до шляху.



documents\example.md



Але треба розуміти, що методи with_name і with_suffix в класі Path модуля pathlib в Python не змінюють фізичне ім'я файлу на диску. Замість цього, вони використовуються для створення нового об'єкта Path, який відображає змінений шлях.



✂️ Цей код можна запустити! 

from pathlib import Path

original_path = Path("documents/example.txt")

# Створює новий об'єкт Path з іншим ім'ям файлу
new_path = original_path.with_name("report.txt")

print(original_path)
print(new_path)



У цьому прикладі, original_path залишається незмінним, а new_path є новим об'єктом Path, який відображає шлях з новим іменем файлу.



documents\example.txt
documents\report.txt



Щоб фізично змінити ім'я файлу на диску, потрібно використовувати методи для роботи з файловою системою, наприклад, rename. Цей виклик змінить ім'я файлу example.txt на report.txt у директорії documents на диску.



✂️ Цей код можна запустити! 

from pathlib import Path

original_path = Path("documents/example.txt")

# Створює новий об'єкт Path з іншим ім'ям файлу
new_path = original_path.with_name("report.txt")
original_path.rename(new_path)





Читання та запис файлів

Модуль pathlib надає кілька методів для читання з файлів та запису в них, що зменшує необхідність використання стандартного модуля open. Але вони не замінюють його, а є доповненням.



Методи read_text() та write_text() використовуються для читання та запису текстових файлів.



Синтаксис методу read_text()



Path.read_text(encoding=None, errors=None)



Параметри:



encoding - необов'язковий, ім'я кодування, яке використовується для декодування файлу. Якщо не вказано, використовується кодування за замовчуванням.
errors - необов'язково, інструкція, як обробляти помилки декодування.


Синтаксис методу write_text()



Path.write_text(data, encoding=None, errors=None)



data - рядок, який необхідно записати в файл.
encoding - необов'язковий, ім'я кодування, яке використовується для декодування файлу. Якщо не вказано, використовується кодування за замовчуванням.
errors - необов'язково, інструкція, як обробляти помилки декодування.


Як бачимо параметр errors, в обох методах, визначає, як мають бути оброблені ці помилки.



errors='strict'. Це значення за замовчуванням. Якщо виникає помилка декодування, буде викинуто виключення UnicodeDecodeError.
errors='ignore'. Якщо ми хочемо ігнорувати помилки декодування. Частини тексту, що не можуть бути декодовані, будуть просто пропущені.
errors='replace'. Якщо пропускати ми не хочемо, то замінимо неможливі для декодування символи на спеціальний символ заміни, згідно документації символ '?'.


Приклад запису тексту у файл



✂️ Цей код можна запустити! 

from pathlib import Path

# Створення об'єкту Path для файлу
file_path = Path("example.txt")

# Запис тексту у файл
file_path.write_text("Привіт світ!", encoding="utf-8")




Тут рядок "Привіт світ!" записується в файл example.txt.



Приклад читання тексту з файлу



✂️ Цей код можна запустити! 

from pathlib import Path

# Створення об'єкту Path для файлу
file_path = Path("example.txt")

# Читання тексту з файлу
text = file_path.read_text(encoding="utf-8")
print(text)



У цьому прикладі текст з файлу example.txt читається за допомогою read_text() та виводиться на екран.



Виведення:

Привіт світ!



Методи read_bytes() та write_bytes() використовуються для читання та запису бінарних файлів.



Приклад запису бінарних даних у файл



✂️ Цей код можна запустити! 

from pathlib import Path

# Створення об'єкту Path для бінарного файлу
file_path = Path("example.bin")

# Бінарні дані для запису
data = b"Python is great!"

# Запис байтів у файл
file_path.write_bytes(data)



Тут бінарні дані data записуються в файл example.bin.



Приклад читання бінарних даних з файлу



✂️ Цей код можна запустити! 

from pathlib import Path

# Створення об'єкту Path для бінарного файлу
file_path = Path("example.bin")

# Читання байтів з файлу
binary_data = file_path.read_bytes()
print(binary_data)



У цьому випадку бінарні дані з файлу example.bin читаються за допомогою read_bytes().



Виведення:



b'Python is great!'





Робота з директоріями

Модуль pathlib в Python включає функціонал для ефективної роботи з файловою системою, зокрема з директоріями.



Метод iterdir() використовується для отримання переліку всіх файлів та піддиректорій у вказаній директорії. Цей метод повертає ітератор, який виробляє об'єкти Path для кожного файлу та піддиректорії у директорії, що визначена поточним об'єктом Path.



Розглянемо приклад використання. В нас є скрипт ex01.py з наступним кодом:



✂️ Цей код можна запустити! 

from pathlib import Path

# Створення об'єкту Path для директорії
directory = Path("./picture")

# Виведення переліку всіх файлів та піддиректорій
for path in directory.iterdir():
    print(path)



Ми виведемо список елементів з директорії "./picture" яка знаходить в середині директорії проєкту core_course, де ми запускаємо скрипт ex01.py.

Маємо таку структуру каталогів:



📦core_course
 ┣ 📂picture
 ┃ ┣ 📂Logo
 ┃ ┣ 📜bot-icon.png
 ┃ ┗ 📜mongodb.jpg
 ┗ 📜ex01.py



В нашому випадку тоді виведення буде:



picture\bot-icon.png
picture\Logo
picture\mongodb.jpg



Для створення нової директорії використовується метод mkdir().



Path.mkdir(mode=0o777, parents=False, exist_ok=False)



Параметри:



mode - права доступу до директорії, використовуються для Linux і не актуальні для Windows.
parents - якщо має значення True, створить всі батьківські директорії, які відсутні.
exist_ok - якщо має значення True, помилка не буде викинута, якщо директорія вже існує.


Приклад:



✂️ Цей код можна запустити! 

from pathlib import Path
directory = Path('/my_directory/new_folder')
directory.mkdir(parents=True, exist_ok=True)



Для видалення директорії використовується метод rmdir(). Він видаляє директорію, але директорія повинна бути порожньою.



✂️ Цей код можна запустити! 

from pathlib import Path
directory = Path('/my_directory/new_folder')
directory.rmdir()



Модуль pathlib також надає декілька методів для перевірки існування та типу файлових об'єктів:



метод exists() перевіряє, чи існує файл або директорія.
метод is_dir() перевіряє, чи є об'єкт директорією.
метод is_file() перевіряє, чи є об'єкт файлом.


Приклади використання



✂️ Цей код можна запустити! 

from pathlib import Path

path = Path("./picture")

# Перевірка існування
if path.exists():
    print(f"{path} існує")

# Перевірка, чи це директорія
if path.is_dir():
    print(f"{path} є директорією")

# Перевірка, чи це файл
if path.is_file():
    print(f"{path} є файлом")



Виведення:

picture існує
picture є директорією





Переміщення та копіювання файлів

Модуль pathlib чудово інтегрується з модулем shutil для виконання операцій копіювання та переміщення файлів. Для копіювання файлів використовується функція shutil.copy() або shutil.copy2().



Приклад копіювання файлу:



✂️ Цей код можна запустити! 

import shutil
from pathlib import Path

# Вихідний і цільовий файли
source = Path('/path/to/source/file.txt')
destination = Path('/path/to/destination/file.txt')

# Копіювання файла
shutil.copy(source, destination)



Функція shutil.copy() копіює вміст файлу, але не копіює метадані, тоді як shutil.copy2() копіює і вміст, і метадані.



Для переміщення файлів використовується функція shutil.move().



Приклад переміщення файлу:



✂️ Цей код можна запустити! 

import shutil
from pathlib import Path

# Вихідний і цільовий шляхи
source = Path('/path/to/source/file.txt')
destination = Path('/path/to/destination/file.txt')

# Переміщення файла
shutil.move(source, destination)



Метод stat() повертає інформацію про файл, включаючи його розмір.



Отримання розміру файлу



✂️ Цей код можна запустити! 

from pathlib import Path

file_path = Path("./picture/bot-icon.png")

# Отримання розміру файла
size = file_path.stat().st_size
print(f"Розмір файла: {size} байтів")



Виведення:



Розмір файла: 2876 байтів



Метод stat() також надає час створення, атрибут st_ctime, та час останньої модифікації файлу, атрибут st_mtime.



✂️ Цей код можна запустити! 

from pathlib import Path
import time

file_path = Path("./picture/bot-icon.png")

# Час створення та модифікації
creation_time = file_path.stat().st_ctime
modification_time = file_path.stat().st_mtime

print(f"Час створення: {time.ctime(creation_time)}")
print(f"Час модифікації: {time.ctime(modification_time)}")



Виведення:



Час створення: Fri Dec 29 04:43:16 2023
Час модифікації: Thu May 17 19:59:44 2018



І остання необхідна інформація для роботи з файлами це видалення. Для видалення файлу використовується метод unlink(). Він видаляє файл, на який вказує об'єкт Path.



Синтаксис:



Path.unlink(missing_ok=False)



Параметр missing_ok якщо має значення True, то виключення не буде викинуто, якщо файл не існує. За замовчуванням False, це означає, що буде викинуто виняток FileNotFoundError, якщо файл не існує.



✂️ Цей код можна запустити! 

from pathlib import Path

# Створення об'єкту Path для файлу
file_path = Path('/path/to/file.txt')

# Перевірка, чи файл існує, перш ніж видаляти
if file_path.exists():
    file_path.unlink()
    print(f'Файл {file_path} було видалено')
else:
    print(f'Файл {file_path} не існує')



У цьому прикладі, перш ніж видалити файл, ми перевіряємо, чи він існує, щоб уникнути виключення FileNotFoundError.



Можна також видалити файл без попередньої перевірки його існування, використовуючи параметр missing_ok.



from pathlib import Path
file_path = Path('/path/to/file.txt')
file_path.unlink(missing_ok=True)



У цьому випадку, якщо файл не існує, виключення не буде викинуто.
'''






















